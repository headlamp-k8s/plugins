{"version":3,"file":"react-hotkeys-hook.cjs.production.min.js","sources":["../src/parseHotkeys.ts","../src/isHotkeyPressed.ts","../src/validators.ts","../src/BoundHotkeysProxyProvider.tsx","../src/deepEqual.ts","../src/HotkeysProvider.tsx","../src/useHotkeys.ts","../src/useDeepEqualMemo.ts","../src/useRecordHotkeys.ts"],"sourcesContent":["import { Hotkey, KeyboardModifiers } from './types'\n\nconst reservedModifierKeywords = ['shift', 'alt', 'meta', 'mod', 'ctrl']\n\nconst mappedKeys: Record<string, string> = {\n  esc: 'escape',\n  return: 'enter',\n  '.': 'period',\n  ',': 'comma',\n  '-': 'slash',\n  ' ': 'space',\n  '`': 'backquote',\n  '#': 'backslash',\n  '+': 'bracketright',\n  ShiftLeft: 'shift',\n  ShiftRight: 'shift',\n  AltLeft: 'alt',\n  AltRight: 'alt',\n  MetaLeft: 'meta',\n  MetaRight: 'meta',\n  OSLeft: 'meta',\n  OSRight: 'meta',\n  ControlLeft: 'ctrl',\n  ControlRight: 'ctrl',\n}\n\nexport function mapKey(key?: string): string {\n  return ((key && mappedKeys[key]) || key || '')\n    .trim()\n    .toLowerCase()\n    .replace(/key|digit|numpad|arrow/, '')\n}\n\nexport function isHotkeyModifier(key: string) {\n  return reservedModifierKeywords.includes(key)\n}\n\nexport function parseKeysHookInput(keys: string, splitKey = ','): string[] {\n  return keys.split(splitKey)\n}\n\nexport function parseHotkey(hotkey: string, combinationKey = '+', description?: string): Hotkey {\n  const keys = hotkey\n    .toLocaleLowerCase()\n    .split(combinationKey)\n    .map((k) => mapKey(k))\n\n  const modifiers: KeyboardModifiers = {\n    alt: keys.includes('alt'),\n    ctrl: keys.includes('ctrl') || keys.includes('control'),\n    shift: keys.includes('shift'),\n    meta: keys.includes('meta'),\n    mod: keys.includes('mod'),\n  }\n\n  const singleCharKeys = keys.filter((k) => !reservedModifierKeywords.includes(k))\n\n  return {\n    ...modifiers,\n    keys: singleCharKeys,\n    description,\n    hotkey,\n  }\n}\n","import { isHotkeyModifier, mapKey } from './parseHotkeys'\n;(() => {\n  if (typeof document !== 'undefined') {\n    document.addEventListener('keydown', (e) => {\n      if (e.key === undefined) {\n        // Synthetic event (e.g., Chrome autofill).  Ignore.\n        return\n      }\n\n      pushToCurrentlyPressedKeys([mapKey(e.key), mapKey(e.code)])\n    })\n\n    document.addEventListener('keyup', (e) => {\n      if (e.key === undefined) {\n        // Synthetic event (e.g., Chrome autofill).  Ignore.\n        return\n      }\n\n      removeFromCurrentlyPressedKeys([mapKey(e.key), mapKey(e.code)])\n    })\n  }\n\n  if (typeof window !== 'undefined') {\n    window.addEventListener('blur', () => {\n      currentlyPressedKeys.clear()\n    })\n  }\n})()\n\nconst currentlyPressedKeys: Set<string> = new Set<string>()\n\n// https://github.com/microsoft/TypeScript/issues/17002\nexport function isReadonlyArray(value: unknown): value is readonly unknown[] {\n  return Array.isArray(value)\n}\n\nexport function isHotkeyPressed(key: string | readonly string[], splitKey = ','): boolean {\n  const hotkeyArray = isReadonlyArray(key) ? key : key.split(splitKey)\n\n  return hotkeyArray.every((hotkey) => currentlyPressedKeys.has(hotkey.trim().toLowerCase()))\n}\n\nexport function pushToCurrentlyPressedKeys(key: string | string[]): void {\n  const hotkeyArray = Array.isArray(key) ? key : [key]\n\n  /*\n  Due to a weird behavior on macOS we need to clear the set if the user pressed down the meta key and presses another key.\n  https://stackoverflow.com/questions/11818637/why-does-javascript-drop-keyup-events-when-the-metakey-is-pressed-on-mac-browser\n  Otherwise the set will hold all ever pressed keys while the meta key is down which leads to wrong results.\n   */\n  if (currentlyPressedKeys.has('meta')) {\n    currentlyPressedKeys.forEach((key) => !isHotkeyModifier(key) && currentlyPressedKeys.delete(key.toLowerCase()))\n  }\n\n  hotkeyArray.forEach((hotkey) => currentlyPressedKeys.add(hotkey.toLowerCase()))\n}\n\nexport function removeFromCurrentlyPressedKeys(key: string | string[]): void {\n  const hotkeyArray = Array.isArray(key) ? key : [key]\n\n  /*\n  Due to a weird behavior on macOS we need to clear the set if the user pressed down the meta key and presses another key.\n  https://stackoverflow.com/questions/11818637/why-does-javascript-drop-keyup-events-when-the-metakey-is-pressed-on-mac-browser\n  Otherwise the set will hold all ever pressed keys while the meta key is down which leads to wrong results.\n   */\n  if (key === 'meta') {\n    currentlyPressedKeys.clear()\n  } else {\n    hotkeyArray.forEach((hotkey) => currentlyPressedKeys.delete(hotkey.toLowerCase()))\n  }\n}\n","import { FormTags, Hotkey, Scopes, Trigger } from './types'\nimport { isHotkeyPressed, isReadonlyArray } from './isHotkeyPressed'\nimport { mapKey } from './parseHotkeys'\n\nexport function maybePreventDefault(e: KeyboardEvent, hotkey: Hotkey, preventDefault?: Trigger): void {\n  if ((typeof preventDefault === 'function' && preventDefault(e, hotkey)) || preventDefault === true) {\n    e.preventDefault()\n  }\n}\n\nexport function isHotkeyEnabled(e: KeyboardEvent, hotkey: Hotkey, enabled?: Trigger): boolean {\n  if (typeof enabled === 'function') {\n    return enabled(e, hotkey)\n  }\n\n  return enabled === true || enabled === undefined\n}\n\nexport function isKeyboardEventTriggeredByInput(ev: KeyboardEvent): boolean {\n  return isHotkeyEnabledOnTag(ev, ['input', 'textarea', 'select'])\n}\n\nexport function isHotkeyEnabledOnTag(\n  event: KeyboardEvent,\n  enabledOnTags: readonly FormTags[] | boolean = false\n): boolean {\n  const {target, composed} = event;\n\n  let targetTagName: string | null = null\n\n  if (isCustomElement(target as HTMLElement) && composed) {\n    targetTagName = event.composedPath()[0] && (event.composedPath()[0] as HTMLElement).tagName;\n  } else {\n    targetTagName = target && (target as HTMLElement).tagName;\n  }\n\n  if (isReadonlyArray(enabledOnTags)) {\n    return Boolean(\n      targetTagName && enabledOnTags && enabledOnTags.some((tag) => tag.toLowerCase() === targetTagName?.toLowerCase())\n    )\n  }\n\n  return Boolean(targetTagName && enabledOnTags && enabledOnTags)\n}\n\nexport function isCustomElement(element: HTMLElement): boolean {\n  // We just do a basic check w/o any complex RegEx or validation against the list of legacy names containing a hyphen,\n  // as none of them is likely to be an event target, and it won't hurt anyway if we miss.\n  // see: https://html.spec.whatwg.org/multipage/custom-elements.html#prod-potentialcustomelementname\n  return !!element.tagName && !element.tagName.startsWith(\"-\") && element.tagName.includes(\"-\");\n}\n\nexport function isScopeActive(activeScopes: string[], scopes?: Scopes): boolean {\n  if (activeScopes.length === 0 && scopes) {\n    console.warn(\n      'A hotkey has the \"scopes\" option set, however no active scopes were found. If you want to use the global scopes feature, you need to wrap your app in a <HotkeysProvider>'\n    )\n\n    return true\n  }\n\n  if (!scopes) {\n    return true\n  }\n\n  return activeScopes.some((scope) => scopes.includes(scope)) || activeScopes.includes('*')\n}\n\nexport const isHotkeyMatchingKeyboardEvent = (e: KeyboardEvent, hotkey: Hotkey, ignoreModifiers = false): boolean => {\n  const { alt, meta, mod, shift, ctrl, keys } = hotkey\n  const { key: pressedKeyUppercase, code, ctrlKey, metaKey, shiftKey, altKey } = e\n\n  const keyCode = mapKey(code)\n  const pressedKey = pressedKeyUppercase.toLowerCase()\n\n  if (\n    !keys?.includes(keyCode) &&\n    !keys?.includes(pressedKey) &&\n    !['ctrl', 'control', 'unknown', 'meta', 'alt', 'shift', 'os'].includes(keyCode)\n  ) {\n    return false\n  }\n\n  if (!ignoreModifiers) {\n    // We check the pressed keys for compatibility with the keyup event. In keyup events the modifier flags are not set.\n    if (alt === !altKey && pressedKey !== 'alt') {\n      return false\n    }\n\n    if (shift === !shiftKey && pressedKey !== 'shift') {\n      return false\n    }\n\n    // Mod is a special key name that is checking for meta on macOS and ctrl on other platforms\n    if (mod) {\n      if (!metaKey && !ctrlKey) {\n        return false\n      }\n    } else {\n      if (meta === !metaKey && pressedKey !== 'meta' && pressedKey !== 'os') {\n        return false\n      }\n\n      if (ctrl === !ctrlKey && pressedKey !== 'ctrl' && pressedKey !== 'control') {\n        return false\n      }\n    }\n  }\n\n  // All modifiers are correct, now check the key\n  // If the key is set, we check for the key\n  if (keys && keys.length === 1 && (keys.includes(pressedKey) || keys.includes(keyCode))) {\n    return true\n  } else if (keys) {\n    // Check if all keys are present in pressedDownKeys set\n    return isHotkeyPressed(keys)\n  } else if (!keys) {\n    // If the key is not set, we only listen for modifiers, that check went alright, so we return true\n    return true\n  }\n\n  // There is nothing that matches.\n  return false\n}\n","import { createContext, ReactNode, useContext } from 'react'\nimport { Hotkey } from './types'\n\ntype BoundHotkeysProxyProviderType = {\n  addHotkey: (hotkey: Hotkey) => void\n  removeHotkey: (hotkey: Hotkey) => void\n}\n\nconst BoundHotkeysProxyProvider = createContext<BoundHotkeysProxyProviderType | undefined>(undefined)\n\nexport const useBoundHotkeysProxy = () => {\n  return useContext(BoundHotkeysProxyProvider)\n}\n\ninterface Props {\n  children: ReactNode\n  addHotkey: (hotkey: Hotkey) => void\n  removeHotkey: (hotkey: Hotkey) => void\n}\n\nexport default function BoundHotkeysProxyProviderProvider({ addHotkey, removeHotkey, children }: Props) {\n  return (\n    <BoundHotkeysProxyProvider.Provider value={{ addHotkey, removeHotkey }}>\n      {children}\n    </BoundHotkeysProxyProvider.Provider>\n  )\n}\n","export default function deepEqual(x: any, y: any): boolean {\n  //@ts-ignore\n  return x && y && typeof x === 'object' && typeof y === 'object'\n    ? Object.keys(x).length === Object.keys(y).length &&\n        //@ts-ignore\n        Object.keys(x).reduce((isEqual, key) => isEqual && deepEqual(x[key], y[key]), true)\n    : x === y\n}\n","import { Hotkey } from './types'\nimport { createContext, ReactNode, useState, useContext, useCallback } from 'react'\nimport BoundHotkeysProxyProviderProvider from './BoundHotkeysProxyProvider'\nimport deepEqual from './deepEqual'\n\nexport type HotkeysContextType = {\n  hotkeys: ReadonlyArray<Hotkey>\n  enabledScopes: string[]\n  toggleScope: (scope: string) => void\n  enableScope: (scope: string) => void\n  disableScope: (scope: string) => void\n}\n\n// The context is only needed for special features like global scoping, so we use a graceful default fallback\nconst HotkeysContext = createContext<HotkeysContextType>({\n  hotkeys: [],\n  enabledScopes: [], // This array has to be empty instead of containing '*' as default, to check if the provider is set or not\n  toggleScope: () => {},\n  enableScope: () => {},\n  disableScope: () => {},\n})\n\nexport const useHotkeysContext = () => {\n  return useContext(HotkeysContext)\n}\n\ninterface Props {\n  initiallyActiveScopes?: string[]\n  children: ReactNode\n}\n\nexport const HotkeysProvider = ({ initiallyActiveScopes = ['*'], children }: Props) => {\n  const [internalActiveScopes, setInternalActiveScopes] = useState(\n    initiallyActiveScopes?.length > 0 ? initiallyActiveScopes : ['*']\n  )\n  const [boundHotkeys, setBoundHotkeys] = useState<Hotkey[]>([])\n\n  const enableScope = useCallback((scope: string) => {\n    setInternalActiveScopes((prev) => {\n      if (prev.includes('*')) {\n        return [scope]\n      }\n\n      return Array.from(new Set([...prev, scope]))\n    })\n  }, [])\n\n  const disableScope = useCallback((scope: string) => {\n    setInternalActiveScopes((prev) => {\n      if (prev.filter((s) => s !== scope).length === 0) {\n        return ['*']\n      } else {\n        return prev.filter((s) => s !== scope)\n      }\n    })\n  }, [])\n\n  const toggleScope = useCallback((scope: string) => {\n    setInternalActiveScopes((prev) => {\n      if (prev.includes(scope)) {\n        if (prev.filter((s) => s !== scope).length === 0) {\n          return ['*']\n        } else {\n          return prev.filter((s) => s !== scope)\n        }\n      } else {\n        if (prev.includes('*')) {\n          return [scope]\n        }\n\n        return Array.from(new Set([...prev, scope]))\n      }\n    })\n  }, [])\n\n  const addBoundHotkey = useCallback((hotkey: Hotkey) => {\n    setBoundHotkeys((prev) => [...prev, hotkey])\n  }, [])\n\n  const removeBoundHotkey = useCallback((hotkey: Hotkey) => {\n    setBoundHotkeys((prev) => prev.filter((h) => !deepEqual(h, hotkey)))\n  }, [])\n\n  return (\n    <HotkeysContext.Provider\n      value={{ enabledScopes: internalActiveScopes, hotkeys: boundHotkeys, enableScope, disableScope, toggleScope }}\n    >\n      <BoundHotkeysProxyProviderProvider addHotkey={addBoundHotkey} removeHotkey={removeBoundHotkey}>\n        {children}\n      </BoundHotkeysProxyProviderProvider>\n    </HotkeysContext.Provider>\n  )\n}\n","import { HotkeyCallback, Keys, Options, OptionsOrDependencyArray, RefType } from './types'\nimport { DependencyList, RefCallback, useCallback, useEffect, useState, useLayoutEffect, useRef } from 'react'\nimport { mapKey, parseHotkey, parseKeysHookInput } from './parseHotkeys'\nimport {\n  isHotkeyEnabled,\n  isHotkeyEnabledOnTag,\n  isHotkeyMatchingKeyboardEvent,\n  isKeyboardEventTriggeredByInput,\n  isScopeActive,\n  maybePreventDefault,\n} from './validators'\nimport { useHotkeysContext } from './HotkeysProvider'\nimport { useBoundHotkeysProxy } from './BoundHotkeysProxyProvider'\nimport useDeepEqualMemo from './useDeepEqualMemo'\nimport { isReadonlyArray, pushToCurrentlyPressedKeys, removeFromCurrentlyPressedKeys } from './isHotkeyPressed'\n\nconst stopPropagation = (e: KeyboardEvent): void => {\n  e.stopPropagation()\n  e.preventDefault()\n  e.stopImmediatePropagation()\n}\n\nconst useSafeLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect\n\nexport default function useHotkeys<T extends HTMLElement>(\n  keys: Keys,\n  callback: HotkeyCallback,\n  options?: OptionsOrDependencyArray,\n  dependencies?: OptionsOrDependencyArray\n) {\n  const [ref, setRef] = useState<RefType<T>>(null)\n  const hasTriggeredRef = useRef(false)\n\n  const _options: Options | undefined = !(options instanceof Array)\n    ? (options as Options)\n    : !(dependencies instanceof Array)\n    ? (dependencies as Options)\n    : undefined\n  const _keys: string = isReadonlyArray(keys) ? keys.join(_options?.splitKey) : keys\n  const _deps: DependencyList | undefined =\n    options instanceof Array ? options : dependencies instanceof Array ? dependencies : undefined\n\n  const memoisedCB = useCallback(callback, _deps ?? [])\n  const cbRef = useRef<HotkeyCallback>(memoisedCB)\n\n  if (_deps) {\n    cbRef.current = memoisedCB\n  } else {\n    cbRef.current = callback\n  }\n\n  const memoisedOptions = useDeepEqualMemo(_options)\n\n  const { enabledScopes } = useHotkeysContext()\n  const proxy = useBoundHotkeysProxy()\n\n  useSafeLayoutEffect(() => {\n    if (memoisedOptions?.enabled === false || !isScopeActive(enabledScopes, memoisedOptions?.scopes)) {\n      return\n    }\n\n    const listener = (e: KeyboardEvent, isKeyUp = false) => {\n      if (isKeyboardEventTriggeredByInput(e) && !isHotkeyEnabledOnTag(e, memoisedOptions?.enableOnFormTags)) {\n        return\n      }\n\n      // TODO: SINCE THE EVENT IS NOW ATTACHED TO THE REF, THE ACTIVE ELEMENT CAN NEVER BE INSIDE THE REF. THE HOTKEY ONLY TRIGGERS IF THE\n      // REF IS THE ACTIVE ELEMENT. THIS IS A PROBLEM SINCE FOCUSED SUB COMPONENTS WON'T TRIGGER THE HOTKEY.\n      if (ref !== null) {\n        const rootNode = ref.getRootNode()\n        if (\n          (rootNode instanceof Document || rootNode instanceof ShadowRoot) &&\n          rootNode.activeElement !== ref &&\n          !ref.contains(rootNode.activeElement)\n        ) {\n          stopPropagation(e)\n          return\n        }\n      }\n\n      if ((e.target as HTMLElement)?.isContentEditable && !memoisedOptions?.enableOnContentEditable) {\n        return\n      }\n\n      parseKeysHookInput(_keys, memoisedOptions?.splitKey).forEach((key) => {\n        const hotkey = parseHotkey(key, memoisedOptions?.combinationKey)\n\n        if (isHotkeyMatchingKeyboardEvent(e, hotkey, memoisedOptions?.ignoreModifiers) || hotkey.keys?.includes('*')) {\n          if (memoisedOptions?.ignoreEventWhen?.(e)) {\n            return\n          }\n\n          if (isKeyUp && hasTriggeredRef.current) {\n            return\n          }\n\n          maybePreventDefault(e, hotkey, memoisedOptions?.preventDefault)\n\n          if (!isHotkeyEnabled(e, hotkey, memoisedOptions?.enabled)) {\n            stopPropagation(e)\n\n            return\n          }\n\n          // Execute the user callback for that hotkey\n          cbRef.current(e, hotkey)\n\n          if (!isKeyUp) {\n            hasTriggeredRef.current = true\n          }\n        }\n      })\n    }\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === undefined) {\n        // Synthetic event (e.g., Chrome autofill).  Ignore.\n        return\n      }\n\n      pushToCurrentlyPressedKeys(mapKey(event.code))\n\n      if ((memoisedOptions?.keydown === undefined && memoisedOptions?.keyup !== true) || memoisedOptions?.keydown) {\n        listener(event)\n      }\n    }\n\n    const handleKeyUp = (event: KeyboardEvent) => {\n      if (event.key === undefined) {\n        // Synthetic event (e.g., Chrome autofill).  Ignore.\n        return\n      }\n\n      removeFromCurrentlyPressedKeys(mapKey(event.code))\n\n      hasTriggeredRef.current = false\n\n      if (memoisedOptions?.keyup) {\n        listener(event, true)\n      }\n    }\n\n    const domNode = ref || _options?.document || document\n\n    // @ts-ignore\n    domNode.addEventListener('keyup', handleKeyUp)\n    // @ts-ignore\n    domNode.addEventListener('keydown', handleKeyDown)\n\n    if (proxy) {\n      parseKeysHookInput(_keys, memoisedOptions?.splitKey).forEach((key) =>\n        proxy.addHotkey(parseHotkey(key, memoisedOptions?.combinationKey, memoisedOptions?.description))\n      )\n    }\n\n    return () => {\n      // @ts-ignore\n      domNode.removeEventListener('keyup', handleKeyUp)\n      // @ts-ignore\n      domNode.removeEventListener('keydown', handleKeyDown)\n\n      if (proxy) {\n        parseKeysHookInput(_keys, memoisedOptions?.splitKey).forEach((key) =>\n          proxy.removeHotkey(parseHotkey(key, memoisedOptions?.combinationKey, memoisedOptions?.description))\n        )\n      }\n    }\n  }, [ref, _keys, memoisedOptions, enabledScopes])\n\n  return setRef as RefCallback<T>\n}\n","import { useRef } from 'react'\nimport deepEqual from './deepEqual'\n\nexport default function useDeepEqualMemo<T>(value: T) {\n  const ref = useRef<T | undefined>(undefined)\n\n  if (!deepEqual(ref.current, value)) {\n    ref.current = value\n  }\n\n  return ref.current\n}\n","import { useCallback, useState } from 'react'\nimport { mapKey } from './parseHotkeys'\n\nexport default function useRecordHotkeys() {\n  const [keys, setKeys] = useState(new Set<string>())\n  const [isRecording, setIsRecording] = useState(false)\n\n  const handler = useCallback((event: KeyboardEvent) => {\n    if (event.key === undefined) {\n      // Synthetic event (e.g., Chrome autofill).  Ignore.\n      return\n    }\n\n    event.preventDefault()\n    event.stopPropagation()\n\n    setKeys((prev) => {\n      const newKeys = new Set(prev)\n\n      newKeys.add(mapKey(event.code))\n\n      return newKeys\n    })\n  }, [])\n\n  const stop = useCallback(() => {\n    if (typeof document !== 'undefined') {\n      document.removeEventListener('keydown', handler)\n\n      setIsRecording(false)\n    }\n  }, [handler])\n\n  const start = useCallback(() => {\n    setKeys(new Set<string>())\n\n    if (typeof document !== 'undefined') {\n      stop()\n\n      document.addEventListener('keydown', handler)\n\n      setIsRecording(true)\n    }\n  }, [handler, stop])\n\n  const resetKeys = useCallback(() => {\n    setKeys(new Set<string>())\n  }, [])\n\n  return [keys, { start, stop, resetKeys, isRecording }] as const\n}\n"],"names":["reservedModifierKeywords","mappedKeys","esc","return",".",",","-"," ","`","#","+","ShiftLeft","ShiftRight","AltLeft","AltRight","MetaLeft","MetaRight","OSLeft","OSRight","ControlLeft","ControlRight","mapKey","key","trim","toLowerCase","replace","parseKeysHookInput","keys","splitKey","split","parseHotkey","hotkey","combinationKey","description","toLocaleLowerCase","map","k","_extends","alt","includes","ctrl","shift","meta","mod","filter","document","addEventListener","e","undefined","pushToCurrentlyPressedKeys","code","removeFromCurrentlyPressedKeys","window","currentlyPressedKeys","clear","Set","isReadonlyArray","value","Array","isArray","isHotkeyPressed","every","has","hotkeyArray","forEach","isHotkeyModifier","add","isHotkeyEnabledOnTag","event","enabledOnTags","element","targetTagName","target","composed","tagName","startsWith","composedPath","Boolean","some","tag","_targetTagName","BoundHotkeysProxyProvider","createContext","BoundHotkeysProxyProviderProvider","_ref","_jsx","Provider","addHotkey","removeHotkey","children","deepEqual","x","y","Object","length","reduce","isEqual","HotkeysContext","hotkeys","enabledScopes","toggleScope","enableScope","disableScope","useHotkeysContext","useContext","stopPropagation","preventDefault","stopImmediatePropagation","useSafeLayoutEffect","useLayoutEffect","useEffect","initiallyActiveScopes","_ref$initiallyActiveS","_useState","useState","internalActiveScopes","setInternalActiveScopes","_useState2","boundHotkeys","setBoundHotkeys","useCallback","scope","prev","from","concat","s","addBoundHotkey","removeBoundHotkey","h","callback","options","dependencies","ref","setRef","hasTriggeredRef","useRef","_options","_keys","join","_deps","memoisedCB","cbRef","current","memoisedOptions","useDeepEqualMemo","proxy","enabled","scopes","activeScopes","console","warn","listener","isKeyUp","enableOnFormTags","rootNode","getRootNode","Document","ShadowRoot","activeElement","contains","_e$target","isContentEditable","enableOnContentEditable","ignoreModifiers","pressedKeyUppercase","ctrlKey","metaKey","shiftKey","altKey","keyCode","pressedKey","isHotkeyMatchingKeyboardEvent","_hotkey$keys","ignoreEventWhen","maybePreventDefault","isHotkeyEnabled","handleKeyDown","keydown","keyup","handleKeyUp","domNode","removeEventListener","setKeys","isRecording","setIsRecording","handler","newKeys","stop","start","resetKeys"],"mappings":"0RAEA,IAAMA,EAA2B,CAAC,QAAS,MAAO,OAAQ,MAAO,QAE3DC,EAAqC,CACzCC,IAAK,SACLC,OAAQ,QACRC,IAAK,SACLC,IAAK,QACLC,IAAK,QACLC,IAAK,QACLC,IAAK,YACLC,IAAK,YACLC,IAAK,eACLC,UAAW,QACXC,WAAY,QACZC,QAAS,MACTC,SAAU,MACVC,SAAU,OACVC,UAAW,OACXC,OAAQ,OACRC,QAAS,OACTC,YAAa,OACbC,aAAc,iBAGAC,EAAOC,GACrB,OAASA,GAAOrB,EAAWqB,IAASA,GAAO,IACxCC,OACAC,cACAC,QAAQ,yBAA0B,aAOvBC,EAAmBC,EAAcC,GAC/C,gBAD+CA,IAAAA,EAAW,KACnDD,EAAKE,MAAMD,YAGJE,EAAYC,EAAgBC,EAAsBC,YAAtBD,IAAAA,EAAiB,KAC3D,IAAML,EAAOI,EACVG,oBACAL,MAAMG,GACNG,KAAI,SAACC,GAAC,OAAKf,EAAOe,MAYrB,OAAAC,KAVqC,CACnCC,IAAKX,EAAKY,SAAS,OACnBC,KAAMb,EAAKY,SAAS,SAAWZ,EAAKY,SAAS,WAC7CE,MAAOd,EAAKY,SAAS,SACrBG,KAAMf,EAAKY,SAAS,QACpBI,IAAKhB,EAAKY,SAAS,SAOnBZ,KAJqBA,EAAKiB,QAAO,SAACR,GAAC,OAAMpC,EAAyBuC,SAASH,MAK3EH,YAAAA,EACAF,OAAAA,IC3DsB,oBAAbc,WACTA,SAASC,iBAAiB,WAAW,SAACC,QACtBC,IAAVD,EAAEzB,KAKN2B,EAA2B,CAAC5B,EAAO0B,EAAEzB,KAAMD,EAAO0B,EAAEG,WAGtDL,SAASC,iBAAiB,SAAS,SAACC,QACpBC,IAAVD,EAAEzB,KAKN6B,EAA+B,CAAC9B,EAAO0B,EAAEzB,KAAMD,EAAO0B,EAAEG,YAItC,oBAAXE,QACTA,OAAON,iBAAiB,QAAQ,WAC9BO,EAAqBC,WAK3B,IAAMD,EAAoC,IAAIE,aAG9BC,EAAgBC,GAC9B,OAAOC,MAAMC,QAAQF,YAGPG,EAAgBtC,EAAiCM,GAG/D,gBAH+DA,IAAAA,EAAW,MACtD4B,EAAgBlC,GAAOA,EAAMA,EAAIO,MAAMD,IAExCiC,OAAM,SAAC9B,GAAM,OAAKsB,EAAqBS,IAAI/B,EAAOR,OAAOC,2BAG9DyB,EAA2B3B,GACzC,IAAMyC,EAAcL,MAAMC,QAAQrC,GAAOA,EAAM,CAACA,GAO5C+B,EAAqBS,IAAI,SAC3BT,EAAqBW,SAAQ,SAAC1C,GAAG,gBDlBJA,GAC/B,OAAOtB,EAAyBuC,SAASjB,GCiBA2C,CAAiB3C,IAAQ+B,SAA4B/B,EAAIE,kBAGlGuC,EAAYC,SAAQ,SAACjC,GAAM,OAAKsB,EAAqBa,IAAInC,EAAOP,2BAGlD2B,EAA+B7B,GAC7C,IAAMyC,EAAcL,MAAMC,QAAQrC,GAAOA,EAAM,CAACA,GAOpC,SAARA,EACF+B,EAAqBC,QAErBS,EAAYC,SAAQ,SAACjC,GAAM,OAAKsB,SAA4BtB,EAAOP,2BC9CvD2C,EACdC,EACAC,YAAAA,IAAAA,GAA+C,GAE/C,IAmB8BC,EAjB1BC,EAFGC,EAAoBJ,EAApBI,OAAQC,EAAYL,EAAZK,SAUf,OALEF,GAc4BD,EAfVE,GAmBHE,UAAYJ,EAAQI,QAAQC,WAAW,MAAQL,EAAQI,QAAQnC,SAAS,MAnB3CkC,EAC5BL,EAAMQ,eAAe,IAAOR,EAAMQ,eAAe,GAAmBF,QAEpEF,GAAWA,EAAuBE,QAGhDlB,EAAgBa,GACXQ,QACLN,GAAiBF,GAAiBA,EAAcS,MAAK,SAACC,GAAG,IAAAC,EAAA,OAAKD,EAAIvD,wBAAawD,EAAKT,UAAAS,EAAexD,mBAIhGqD,QAAQN,GAAiBF,GAAiBA,GA0BnD,IC5DMY,EAA4BC,qBAAyDlC,YAYnEmC,EAAiCC,GACvD,OACEC,MAACJ,EAA0BK,UAAS7B,MAAO,CAAE8B,UAFoBH,EAATG,UAEAC,aAFuBJ,EAAZI,cAEIC,SAFkBL,EAARK,oBCpB7DC,EAAUC,EAAQC,GAExC,OAAOD,GAAKC,GAAkB,iBAAND,GAA+B,iBAANC,EAC7CC,OAAOlE,KAAKgE,GAAGG,SAAWD,OAAOlE,KAAKiE,GAAGE,QAEvCD,OAAOlE,KAAKgE,GAAGI,QAAO,SAACC,EAAS1E,GAAG,OAAK0E,GAAWN,EAAUC,EAAErE,GAAMsE,EAAEtE,OAAO,GAChFqE,IAAMC,ECQZ,IAAMK,EAAiBf,gBAAkC,CACvDgB,QAAS,GACTC,cAAe,GACfC,YAAa,aACbC,YAAa,aACbC,aAAc,eAGHC,EAAoB,WAC/B,OAAOC,aAAWP,ICPdQ,EAAkB,SAAC1D,GACvBA,EAAE0D,kBACF1D,EAAE2D,iBACF3D,EAAE4D,4BAGEC,EAAwC,oBAAXxD,OAAyByD,kBAAkBC,oCDS/C,SAAH1B,WAAM2B,sBAAAA,WAAqBC,EAAG,CAAC,KAAIA,EAAEvB,EAAQL,EAARK,SAC/DwB,EAAwDC,kBACtDH,SAAAA,EAAuBjB,QAAS,EAAIiB,EAAwB,CAAC,MADxDI,EAAoBF,KAAEG,EAAuBH,KAGpDI,EAAwCH,WAAmB,IAApDI,EAAYD,KAAEE,EAAeF,KAE9BhB,EAAcmB,eAAY,SAACC,GAC/BL,GAAwB,SAACM,GACvB,OAAIA,EAAKnF,SAAS,KACT,CAACkF,GAGH/D,MAAMiE,KAAK,IAAIpE,OAAGqE,OAAKF,GAAMD,WAErC,IAEGnB,EAAekB,eAAY,SAACC,GAChCL,GAAwB,SAACM,GACvB,OAA+C,IAA3CA,EAAK9E,QAAO,SAACiF,GAAC,OAAKA,IAAMJ,KAAO3B,OAC3B,CAAC,KAED4B,EAAK9E,QAAO,SAACiF,GAAC,OAAKA,IAAMJ,UAGnC,IAEGrB,EAAcoB,eAAY,SAACC,GAC/BL,GAAwB,SAACM,GACvB,OAAIA,EAAKnF,SAASkF,GAC+B,IAA3CC,EAAK9E,QAAO,SAACiF,GAAC,OAAKA,IAAMJ,KAAO3B,OAC3B,CAAC,KAED4B,EAAK9E,QAAO,SAACiF,GAAC,OAAKA,IAAMJ,KAG9BC,EAAKnF,SAAS,KACT,CAACkF,GAGH/D,MAAMiE,KAAK,IAAIpE,OAAGqE,OAAKF,GAAMD,WAGvC,IAEGK,EAAiBN,eAAY,SAACzF,GAClCwF,GAAgB,SAACG,GAAI,SAAAE,OAASF,GAAM3F,SACnC,IAEGgG,EAAoBP,eAAY,SAACzF,GACrCwF,GAAgB,SAACG,GAAI,OAAKA,EAAK9E,QAAO,SAACoF,GAAC,OAAMtC,EAAUsC,EAAGjG,WAC1D,IAEH,OACEsD,MAACY,EAAeX,UACd7B,MAAO,CAAE0C,cAAegB,EAAsBjB,QAASoB,EAAcjB,YAAAA,EAAaC,aAAAA,EAAcF,YAAAA,GAAcX,SAE9GJ,MAACF,GAAkCI,UAAWuC,EAAgBtC,aAAcuC,EAAkBtC,SAC3FA,oDChET,SACE9D,EACAsG,EACAC,EACAC,GAEA,IAAAlB,EAAsBC,WAAqB,MAApCkB,EAAGnB,KAAEoB,EAAMpB,KACZqB,EAAkBC,UAAO,GAEzBC,EAAkCN,aAAmBxE,MAErDyE,aAAwBzE,WAE1BV,EADCmF,EAFAD,EAICO,EAAgBjF,EAAgB7B,GAAQA,EAAK+G,WAAKF,SAAAA,EAAU5G,UAAYD,EACxEgH,EACJT,aAAmBxE,MAAQwE,EAAUC,aAAwBzE,MAAQyE,OAAenF,EAEhF4F,EAAapB,cAAYS,QAAUU,EAAAA,EAAS,IAC5CE,EAAQN,SAAuBK,GAGnCC,EAAMC,QADJH,EACcC,EAEAX,EAGlB,IAAMc,WChDoCtF,GAC1C,IAAM2E,EAAMG,cAAsBvF,GAMlC,OAJK0C,EAAU0C,EAAIU,QAASrF,KAC1B2E,EAAIU,QAAUrF,GAGT2E,EAAIU,QDyCaE,CAAiBR,GAEjCrC,EAAkBI,IAAlBJ,cACF8C,EH3CCzC,aAAWvB,GG8JlB,OAjHA2B,GAAoB,WAClB,IAAiC,WAA7BmC,SAAAA,EAAiBG,WJL6BC,QIKsBJ,SAAAA,EAAiBI,OJJ/D,KADAC,EIK+BjD,GJJ1CL,QAAgBqD,GAC/BE,QAAQC,KACN,6KAGK,IAGJH,GAIEC,EAAatE,MAAK,SAAC2C,GAAK,OAAK0B,EAAO5G,SAASkF,OAAW2B,EAAa7G,SAAS,MIRnF,KJL0B6G,EAAwBD,EIS5CI,EAAW,SAACxG,EAAkByG,SAClC,YADkCA,IAAAA,GAAU,IJ1CzCrF,EI2CiCpB,EJ3CR,CAAC,QAAS,WAAY,YI2CPoB,EAAqBpB,QAAGgG,SAAAA,EAAiBU,kBAApF,CAMA,GAAY,OAARrB,EAAc,CAChB,IAAMsB,EAAWtB,EAAIuB,cACrB,IACGD,aAAoBE,UAAYF,aAAoBG,aACrDH,EAASI,gBAAkB1B,IAC1BA,EAAI2B,SAASL,EAASI,eAGvB,YADArD,EAAgB1D,WAKfiH,EAAAjH,EAAEyB,UAAFwF,EAA0BC,yBAAsBlB,GAAAA,EAAiBmB,0BAItExI,EAAmB+G,QAAOM,SAAAA,EAAiBnH,UAAUoC,SAAQ,SAAC1C,SACtDS,EAASD,EAAYR,QAAKyH,SAAAA,EAAiB/G,gBAEjD,GJnBqC,SAACe,EAAkBhB,EAAgBoI,YAAAA,IAAAA,GAAkB,GAChG,IAAQ7H,EAAsCP,EAAtCO,IAAKI,EAAiCX,EAAjCW,KAAMC,EAA2BZ,EAA3BY,IAAKF,EAAsBV,EAAtBU,MAAOD,EAAeT,EAAfS,KAAMb,EAASI,EAATJ,KACxByI,EAAkErH,EAAvEzB,IAAgC+I,EAAuCtH,EAAvCsH,QAASC,EAA8BvH,EAA9BuH,QAASC,EAAqBxH,EAArBwH,SAAUC,EAAWzH,EAAXyH,OAE9DC,EAAUpJ,EAF+D0B,EAA7CG,MAG5BwH,EAAaN,EAAoB5I,cAEvC,WACGG,GAAAA,EAAMY,SAASkI,UACf9I,GAAAA,EAAMY,SAASmI,IACf,CAAC,OAAQ,UAAW,UAAW,OAAQ,MAAO,QAAS,MAAMnI,SAASkI,IAEvE,OAAO,EAGT,IAAKN,EAAiB,CAEpB,GAAI7H,KAASkI,GAAyB,QAAfE,EACrB,OAAO,EAGT,GAAIjI,KAAW8H,GAA2B,UAAfG,EACzB,OAAO,EAIT,GAAI/H,GACF,IAAK2H,IAAYD,EACf,OAAO,MAEJ,CACL,GAAI3H,KAAU4H,GAA0B,SAAfI,GAAwC,OAAfA,EAChD,OAAO,EAGT,GAAIlI,KAAU6H,GAA0B,SAAfK,GAAwC,YAAfA,EAChD,OAAO,GAOb,SAAI/I,GAAwB,IAAhBA,EAAKmE,SAAiBnE,EAAKY,SAASmI,KAAe/I,EAAKY,SAASkI,MAElE9I,EAEFiC,EAAgBjC,IACbA,GI7BFgJ,CAA8B5H,EAAGhB,QAAQgH,SAAAA,EAAiBoB,yBAAgBS,EAAI7I,EAAOJ,OAAPiJ,EAAarI,SAAS,KAAM,CAC5G,SAAIwG,SAAAA,EAAiB8B,iBAAjB9B,EAAiB8B,gBAAkB9H,GACrC,OAGF,GAAIyG,GAAWlB,EAAgBQ,QAC7B,OAKF,YJ9F0B/F,EAAkBhB,EAAgB2E,IACrC,mBAAnBA,GAAiCA,EAAe3D,EAAGhB,KAA+B,IAAnB2E,IACzE3D,EAAE2D,iBI0FIoE,CAAoB/H,EAAGhB,QAAQgH,SAAAA,EAAiBrC,iBJtF1D,SAAgC3D,EAAkBhB,EAAgBmH,GAChE,MAAuB,mBAAZA,EACFA,EAAQnG,EAAGhB,IAGD,IAAZmH,QAAgClG,IAAZkG,EImFd6B,CAAgBhI,EAAGhB,QAAQgH,SAAAA,EAAiBG,SAG/C,YAFAzC,EAAgB1D,GAMlB8F,EAAMC,QAAQ/F,EAAGhB,GAEZyH,IACHlB,EAAgBQ,SAAU,SAM5BkC,EAAgB,SAAC5G,QACHpB,IAAdoB,EAAM9C,MAKV2B,EAA2B5B,EAAO+C,EAAMlB,aAENF,WAA7B+F,SAAAA,EAAiBkC,WAAoD,WAA3BlC,SAAAA,EAAiBmC,cAAmBnC,GAAAA,EAAiBkC,UAClG1B,EAASnF,KAIP+G,EAAc,SAAC/G,QACDpB,IAAdoB,EAAM9C,MAKV6B,EAA+B9B,EAAO+C,EAAMlB,OAE5CoF,EAAgBQ,SAAU,QAEtBC,GAAAA,EAAiBmC,OACnB3B,EAASnF,GAAO,KAIdgH,EAAUhD,UAAOI,SAAAA,EAAU3F,WAAYA,SAa7C,OAVAuI,EAAQtI,iBAAiB,QAASqI,GAElCC,EAAQtI,iBAAiB,UAAWkI,GAEhC/B,GACFvH,EAAmB+G,QAAOM,SAAAA,EAAiBnH,UAAUoC,SAAQ,SAAC1C,GAAG,OAC/D2H,EAAM1D,UAAUzD,EAAYR,QAAKyH,SAAAA,EAAiB/G,qBAAgB+G,SAAAA,EAAiB9G,iBAIhF,WAELmJ,EAAQC,oBAAoB,QAASF,GAErCC,EAAQC,oBAAoB,UAAWL,GAEnC/B,GACFvH,EAAmB+G,QAAOM,SAAAA,EAAiBnH,UAAUoC,SAAQ,SAAC1C,GAAG,OAC/D2H,EAAMzD,aAAa1D,EAAYR,QAAKyH,SAAAA,EAAiB/G,qBAAgB+G,SAAAA,EAAiB9G,qBAI3F,CAACmG,EAAKK,EAAOM,EAAiB5C,IAE1BkC,mEErKP,IAAApB,EAAwBC,WAAS,IAAI3D,KAA9B5B,EAAIsF,KAAEqE,EAAOrE,KACpBI,EAAsCH,YAAS,GAAxCqE,EAAWlE,KAAEmE,EAAcnE,KAE5BoE,EAAUjE,eAAY,SAACpD,QACTpB,IAAdoB,EAAM9C,MAKV8C,EAAMsC,iBACNtC,EAAMqC,kBAEN6E,GAAQ,SAAC5D,GACP,IAAMgE,EAAU,IAAInI,IAAImE,GAIxB,OAFAgE,EAAQxH,IAAI7C,EAAO+C,EAAMlB,OAElBwI,QAER,IAEGC,EAAOnE,eAAY,WACC,oBAAb3E,WACTA,SAASwI,oBAAoB,UAAWI,GAExCD,GAAe,MAEhB,CAACC,IAEEG,EAAQpE,eAAY,WACxB8D,EAAQ,IAAI/H,KAEY,oBAAbV,WACT8I,IAEA9I,SAASC,iBAAiB,UAAW2I,GAErCD,GAAe,MAEhB,CAACC,EAASE,IAEPE,EAAYrE,eAAY,WAC5B8D,EAAQ,IAAI/H,OACX,IAEH,MAAO,CAAC5B,EAAM,CAAEiK,MAAAA,EAAOD,KAAAA,EAAME,UAAAA,EAAWN,YAAAA"}