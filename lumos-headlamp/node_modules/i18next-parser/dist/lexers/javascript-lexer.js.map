{"version":3,"file":"javascript-lexer.js","names":["BaseLexer","ts","JavascriptLexer","_BaseLexer","_this","options","arguments","length","undefined","_classCallCheck","_callSuper","callPattern","functionPattern","functions","namespaceFunctions","attr","parseGenerics","typeMap","translationFunctionsWithArgs","_inherits","_createClass","key","value","createCommentNodeParser","_this2","visitedComments","Set","keys","node","content","forEachLeadingCommentRange","getFullStart","pos","end","kind","commentId","concat","SyntaxKind","MultiLineCommentTrivia","SingleLineCommentTrivia","has","add","text","slice","commentKeys","commentExtractor","call","push","apply","_toConsumableArray","setNamespaces","_this3","map","entry","_ref","_entry$ns","_this3$translationFun","namespace","ns","functionName","defaultNamespace","_objectSpread","setKeyPrefixes","_this4","_ref2","_this4$translationFun","_this4$translationFun2","_objectWithoutProperties","_excluded","keyPrefix","variableDeclarationExtractor","_node$name$elements","_ref3","_firstDeconstructedPr","_firstDeconstructedPr2","_node$initializer$exp","firstDeconstructedProp","name","elements","propertyName","escapedText","includes","initializer","expression","_firstDeconstructedPr3","storeGlobally","extract","_this5","filename","parseCommentNode","parseTree","VariableDeclaration","ArrowFunction","FunctionDeclaration","functionParamExtractor","TaggedTemplateExpression","taggedTemplateExpressionExtractor","CallExpression","entries","expressionExtractor","forEachChild","sourceFile","createSourceFile","ScriptTarget","Latest","_this6","tFunctionParam","parameters","find","param","Identifier","type","typeName","typeArguments","LiteralType","literal","tag","template","isTranslationFunction","NoSubstitutionTemplateLiteral","TemplateExpression","emit","_functionDefinition$","_this7","functionDefinition","Object","_ref4","_ref5","_slicedToArray","translationFunc","isNamespaceFunction","expressionToName","namespaceArgument","optionsArgument","namespaces","StringLiteral","ObjectLiteralExpression","keyPrefixNode","properties","p","keyArgument","shift","BinaryExpression","concatenatedString","concatenateString","typeArgument","parseTypeArgument","typeArg","TypeLiteral","_iterator","_createForOfIteratorHelper","members","_step","s","n","done","member","err","e","f","TypeReference","assign","Array","isArray","types","forEach","tp","defaultValue","_iterator2","_step2","SpreadAssignment","TrueKeyword","FalseKeyword","nestedEntries","_typeof","isTranslationFunctionCreation","commentText","_this8","regexp","RegExp","expressions","match","expressionKeys","binaryExpression","string","operatorToken","PlusToken","left","right","filter","join","default"],"sources":["../../src/lexers/javascript-lexer.js"],"sourcesContent":["import BaseLexer from './base-lexer.js'\nimport ts from 'typescript'\n\nexport default class JavascriptLexer extends BaseLexer {\n  constructor(options = {}) {\n    super(options)\n\n    this.callPattern = '(?<=^|\\\\s|\\\\.)' + this.functionPattern() + '\\\\(.*\\\\)'\n    this.functions = options.functions || ['t']\n    this.namespaceFunctions = options.namespaceFunctions || [\n      'useTranslation',\n      'withTranslation',\n    ]\n    this.attr = options.attr || 'i18nKey'\n    this.parseGenerics = options.parseGenerics || false\n    this.typeMap = options.typeMap || {}\n    this.translationFunctionsWithArgs = {}\n  }\n\n  createCommentNodeParser() {\n    const visitedComments = new Set()\n\n    return (keys, node, content) => {\n      ts.forEachLeadingCommentRange(\n        content,\n        node.getFullStart(),\n        (pos, end, kind) => {\n          const commentId = `${pos}_${end}`\n          if (\n            (kind === ts.SyntaxKind.MultiLineCommentTrivia ||\n              kind === ts.SyntaxKind.SingleLineCommentTrivia) &&\n            !visitedComments.has(commentId)\n          ) {\n            visitedComments.add(commentId)\n            const text = content.slice(pos, end)\n            const commentKeys = this.commentExtractor.call(this, text)\n            if (commentKeys) {\n              keys.push(...commentKeys)\n            }\n          }\n        }\n      )\n    }\n  }\n\n  setNamespaces(keys) {\n    return keys.map((entry) => {\n      const namespace =\n        entry.ns ??\n        this.translationFunctionsWithArgs?.[entry.functionName]?.ns ??\n        this.defaultNamespace\n      return namespace\n        ? {\n            ...entry,\n            namespace,\n          }\n        : entry\n    })\n  }\n\n  setKeyPrefixes(keys) {\n    return keys.map(({ functionName, ...key }) => {\n      const keyPrefix =\n        this.translationFunctionsWithArgs?.[functionName]?.keyPrefix ??\n        this.keyPrefix\n      return keyPrefix\n        ? {\n            ...key,\n            keyPrefix,\n          }\n        : key\n    })\n  }\n\n  variableDeclarationExtractor(node) {\n    const firstDeconstructedProp = node.name.elements?.[0]\n    if (\n      (firstDeconstructedProp?.propertyName ?? firstDeconstructedProp?.name)\n        ?.escapedText === 't' &&\n      this.functions.includes(firstDeconstructedProp?.name?.escapedText) &&\n      this.namespaceFunctions.includes(node.initializer.expression?.escapedText)\n    ) {\n      this.translationFunctionsWithArgs[\n        firstDeconstructedProp.name.escapedText\n      ] = {\n        pos: node.initializer.pos,\n        storeGlobally: !firstDeconstructedProp.propertyName?.escapedText,\n      }\n    }\n  }\n\n  extract(content, filename = '__default.js') {\n    const keys = []\n\n    const parseCommentNode = this.createCommentNodeParser()\n\n    const parseTree = (node) => {\n      parseCommentNode(keys, node, content)\n\n      if (node.kind === ts.SyntaxKind.VariableDeclaration) {\n        this.variableDeclarationExtractor.call(this, node)\n      }\n      if (\n        node.kind === ts.SyntaxKind.ArrowFunction ||\n        node.kind === ts.SyntaxKind.FunctionDeclaration\n      ) {\n        this.functionParamExtractor.call(this, node)\n      }\n\n      if (node.kind === ts.SyntaxKind.TaggedTemplateExpression) {\n        const entry = this.taggedTemplateExpressionExtractor.call(this, node)\n        if (entry) {\n          keys.push(entry)\n        }\n      }\n\n      if (node.kind === ts.SyntaxKind.CallExpression) {\n        const entries = this.expressionExtractor.call(this, node)\n        if (entries) {\n          keys.push(...entries)\n        }\n      }\n\n      node.forEachChild(parseTree)\n    }\n\n    const sourceFile = ts.createSourceFile(\n      filename,\n      content,\n      ts.ScriptTarget.Latest\n    )\n    parseTree(sourceFile)\n\n    return this.setKeyPrefixes(this.setNamespaces(keys))\n  }\n\n  /** @param {ts.FunctionLikeDeclaration} node */\n  functionParamExtractor(node) {\n    const tFunctionParam =\n      node.parameters &&\n      node.parameters.find(\n        (param) =>\n          param.name &&\n          param.name.kind === ts.SyntaxKind.Identifier &&\n          this.functions.includes(param.name.text)\n      )\n\n    if (\n      tFunctionParam &&\n      tFunctionParam.type &&\n      tFunctionParam.type.typeName &&\n      tFunctionParam.type.typeName.text === 'TFunction'\n    ) {\n      const { typeArguments } = tFunctionParam.type\n      if (\n        typeArguments &&\n        typeArguments.length &&\n        typeArguments[0].kind === ts.SyntaxKind.LiteralType\n      ) {\n        this.defaultNamespace = typeArguments[0].literal.text\n      }\n    }\n  }\n\n  taggedTemplateExpressionExtractor(node) {\n    const entry = {}\n\n    const { tag, template } = node\n\n    const isTranslationFunction =\n      (tag.text && this.functions.includes(tag.text)) ||\n      (tag.name && this.functions.includes(tag.name.text))\n\n    if (!isTranslationFunction) return null\n\n    if (template.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral) {\n      entry.key = template.text\n    } else if (template.kind === ts.SyntaxKind.TemplateExpression) {\n      this.emit(\n        'warning',\n        'A key that is a template string must not have any interpolations.'\n      )\n      return null\n    }\n\n    return entry\n  }\n\n  expressionExtractor(node) {\n    const entries = [{}]\n\n    const functionDefinition = Object.entries(\n      this.translationFunctionsWithArgs\n    ).find(([name, translationFunc]) => translationFunc?.pos === node.pos)\n    let storeGlobally = functionDefinition?.[1].storeGlobally ?? true\n\n    const isNamespaceFunction =\n      this.namespaceFunctions.includes(node.expression.escapedText) ||\n      // Support matching the namespace as well, i.e. match `i18n.useTranslation('ns')`\n      this.namespaceFunctions.includes(this.expressionToName(node.expression))\n\n    if (isNamespaceFunction && node.arguments.length) {\n      storeGlobally |= node.expression.escapedText === 'withTranslation'\n      const namespaceArgument = node.arguments[0]\n      const optionsArgument = node.arguments[1]\n      // The namespace argument can be either an array of namespaces or a single namespace,\n      // so we convert it to an array in the case of a single namespace so that we can use\n      // the same code in both cases\n      const namespaces = namespaceArgument.elements || [namespaceArgument]\n\n      // Find the first namespace that is a string literal, or is `undefined`. In the case\n      // of `undefined`, we do nothing (see below), leaving the default namespace unchanged\n      const namespace = namespaces.find(\n        (ns) =>\n          ns.kind === ts.SyntaxKind.StringLiteral ||\n          (ns.kind === ts.SyntaxKind.Identifier && ns.text === 'undefined')\n      )\n\n      if (!namespace) {\n        // We know that the namespace argument was provided, so if we're unable to find a\n        // namespace, emit a warning since this will likely cause issues for the user\n        this.emit(\n          'warning',\n          namespaceArgument.kind === ts.SyntaxKind.Identifier\n            ? `Namespace is not a string literal nor an array containing a string literal: ${namespaceArgument.text}`\n            : 'Namespace is not a string literal nor an array containing a string literal'\n        )\n      } else if (namespace.kind === ts.SyntaxKind.StringLiteral) {\n        // We found a string literal namespace, so we'll use this instead of the default\n        if (storeGlobally) {\n          this.defaultNamespace = namespace.text\n        }\n        entries[0].ns = namespace.text\n      }\n\n      if (\n        optionsArgument &&\n        optionsArgument.kind === ts.SyntaxKind.ObjectLiteralExpression\n      ) {\n        const keyPrefixNode = optionsArgument.properties.find(\n          (p) => p.name.escapedText === 'keyPrefix'\n        )\n        if (keyPrefixNode != null) {\n          if (storeGlobally) {\n            this.keyPrefix = keyPrefixNode.initializer.text\n          }\n          entries[0].keyPrefix = keyPrefixNode.initializer.text\n        }\n      }\n    }\n\n    const isTranslationFunction =\n      // If the expression is a string literal, we can just check if it's in the\n      // list of functions\n      (node.expression.text && this.functions.includes(node.expression.text)) ||\n      // Support the case where the function is contained in a namespace, i.e.\n      // match `i18n.t()` when this.functions = ['t'].\n      (node.expression.name &&\n        this.functions.includes(node.expression.name.text)) ||\n      // Support matching the namespace as well, i.e. match `i18n.t()` but _not_\n      // `l10n.t()` when this.functions = ['i18n.t']\n      this.functions.includes(this.expressionToName(node.expression))\n\n    if (isTranslationFunction) {\n      const keyArgument = node.arguments.shift()\n\n      if (!keyArgument) {\n        return null\n      }\n\n      if (\n        keyArgument.kind === ts.SyntaxKind.StringLiteral ||\n        keyArgument.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n      ) {\n        entries[0].key = keyArgument.text\n      } else if (keyArgument.kind === ts.SyntaxKind.BinaryExpression) {\n        const concatenatedString = this.concatenateString(keyArgument)\n        if (!concatenatedString) {\n          this.emit(\n            'warning',\n            `Key is not a string literal: ${keyArgument.text}`\n          )\n          return null\n        }\n        entries[0].key = concatenatedString\n      } else {\n        this.emit(\n          'warning',\n          keyArgument.kind === ts.SyntaxKind.Identifier\n            ? `Key is not a string literal: ${keyArgument.text}`\n            : 'Key is not a string literal'\n        )\n        return null\n      }\n\n      if (this.parseGenerics && node.typeArguments) {\n        let typeArgument = node.typeArguments.shift()\n\n        const parseTypeArgument = (typeArg) => {\n          if (!typeArg) {\n            return\n          }\n          if (typeArg.kind === ts.SyntaxKind.TypeLiteral) {\n            for (const member of typeArg.members) {\n              entries[0][member.name.text] = ''\n            }\n          } else if (\n            typeArg.kind === ts.SyntaxKind.TypeReference &&\n            typeArg.typeName.kind === ts.SyntaxKind.Identifier\n          ) {\n            const typeName = typeArg.typeName.text\n            if (typeName in this.typeMap) {\n              Object.assign(entries[0], this.typeMap[typeName])\n            }\n          } else if (Array.isArray(typeArg.types)) {\n            typeArgument.types.forEach((tp) => parseTypeArgument(tp))\n          }\n        }\n\n        parseTypeArgument(typeArgument)\n      }\n\n      let optionsArgument = node.arguments.shift()\n\n      // Second argument could be a (concatenated) string default value\n      if (\n        optionsArgument &&\n        (optionsArgument.kind === ts.SyntaxKind.StringLiteral ||\n          optionsArgument.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral)\n      ) {\n        entries[0].defaultValue = optionsArgument.text\n        optionsArgument = node.arguments.shift()\n      } else if (\n        optionsArgument &&\n        optionsArgument.kind === ts.SyntaxKind.BinaryExpression\n      ) {\n        const concatenatedString = this.concatenateString(optionsArgument)\n        if (!concatenatedString) {\n          this.emit(\n            'warning',\n            `Default value is not a string literal: ${optionsArgument.text}`\n          )\n          return null\n        }\n        entries[0].defaultValue = concatenatedString\n        optionsArgument = node.arguments.shift()\n      }\n\n      if (\n        optionsArgument &&\n        optionsArgument.kind === ts.SyntaxKind.ObjectLiteralExpression\n      ) {\n        for (const p of optionsArgument.properties) {\n          if (p.kind === ts.SyntaxKind.SpreadAssignment) {\n            this.emit(\n              'warning',\n              `Options argument is a spread operator : ${p.expression.text}`\n            )\n          } else if (p.initializer) {\n            if (p.initializer.kind === ts.SyntaxKind.TrueKeyword) {\n              entries[0][p.name.text] = true\n            } else if (p.initializer.kind === ts.SyntaxKind.FalseKeyword) {\n              entries[0][p.name.text] = false\n            } else if (p.initializer.kind === ts.SyntaxKind.CallExpression) {\n              const nestedEntries = this.expressionExtractor(p.initializer)\n              if (nestedEntries) {\n                entries.push(...nestedEntries)\n              } else {\n                entries[0][p.name.text] = p.initializer.text || ''\n              }\n            } else {\n              entries[0][p.name.text] = p.initializer.text || ''\n            }\n          } else {\n            entries[0][p.name.text] = ''\n          }\n        }\n      }\n\n      if (entries[0].ns) {\n        if (typeof entries[0].ns === 'string') {\n          entries[0].namespace = entries[0].ns\n        } else if (typeof entries.ns === 'object' && entries.ns.length) {\n          entries[0].namespace = entries[0].ns[0]\n        }\n      }\n      entries[0].functionName = node.expression.escapedText\n\n      return entries\n    }\n\n    const isTranslationFunctionCreation =\n      node.expression.escapedText &&\n      this.namespaceFunctions.includes(node.expression.escapedText)\n    if (isTranslationFunctionCreation) {\n      this.translationFunctionsWithArgs[functionDefinition?.[0]] = entries[0]\n    }\n    return null\n  }\n\n  commentExtractor(commentText) {\n    const regexp = new RegExp(this.callPattern, 'g')\n    const expressions = commentText.match(regexp)\n\n    if (!expressions) {\n      return null\n    }\n\n    const keys = []\n    expressions.forEach((expression) => {\n      const expressionKeys = this.extract(expression)\n      if (expressionKeys) {\n        keys.push(...expressionKeys)\n      }\n    })\n    return keys\n  }\n\n  concatenateString(binaryExpression, string = '') {\n    if (binaryExpression.operatorToken.kind !== ts.SyntaxKind.PlusToken) {\n      return\n    }\n\n    if (binaryExpression.left.kind === ts.SyntaxKind.BinaryExpression) {\n      string += this.concatenateString(binaryExpression.left, string)\n    } else if (binaryExpression.left.kind === ts.SyntaxKind.StringLiteral) {\n      string += binaryExpression.left.text\n    } else {\n      return\n    }\n\n    if (binaryExpression.right.kind === ts.SyntaxKind.BinaryExpression) {\n      string += this.concatenateString(binaryExpression.right, string)\n    } else if (binaryExpression.right.kind === ts.SyntaxKind.StringLiteral) {\n      string += binaryExpression.right.text\n    } else {\n      return\n    }\n\n    return string\n  }\n\n  /**\n   * Recursively computes the name of a dot-separated expression, e.g. `t` or `t.ns`\n   * @type {(expression: ts.LeftHandSideExpression | ts.JsxTagNameExpression) => string}\n   */\n  expressionToName(expression) {\n    if (expression) {\n      if (expression.text) {\n        return expression.text\n      } else if (expression.name) {\n        return [\n          this.expressionToName(expression.expression),\n          this.expressionToName(expression.name),\n        ]\n          .filter((s) => s && s.length > 0)\n          .join('.')\n      }\n    }\n    return undefined\n  }\n}\n"],"mappings":"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"}