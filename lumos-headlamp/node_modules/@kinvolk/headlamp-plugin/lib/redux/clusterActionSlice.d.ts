import { OptionsObject as SnackbarProps } from 'notistack';
/**
 * See components/common/ActionsNotifier.tsx for a user of cluster actions.
 */
type ActionState = 'start' | 'complete' | 'error';
/**
 * A button to display on the action.
 */
export interface ClusterActionButton {
    /**
     * The label to display on the button.
     */
    label: string;
    /**
     * The action to dispatch when the button is clicked.
     */
    actionToDispatch: string;
}
export interface ClusterAction {
    /**
     * A unique id for the action.
     */
    id: string;
    /**
     * A unique id for the action.
     */
    key?: string;
    /**
     * The amount of time to display the snackbar.
     */
    autoHideDuration?: number;
    /**
     * The message to display on the action.
     */
    message?: string;
    /**
     * The url to navigate to when the action is complete.
     */
    url?: string;
    /**
     * The state of the action. Helps identify if in progress, complete, or failed.
     */
    state?: ActionState;
    /**
     * The buttons to display on the action.
     */
    buttons?: ClusterActionButton[];
    /**
     * The id of the snackbar to dismiss.
     */
    dismissSnackbar?: string;
    /**
     * The props to pass to the snackbar. Could be { variant: 'success' }.
     */
    snackbarProps?: SnackbarProps;
}
export interface CallbackAction extends CallbackActionOptions {
    callback: (...args: any[]) => void;
}
export interface CallbackActionOptions {
    /**
     * The url to navigate to when the action has started.
     */
    startUrl?: string;
    /**
     * The url to navigate to when it is cancelled.
     */
    cancelUrl?: string;
    /**
     * The url to navigate to when there is an error.
     */
    errorUrl?: string;
    /**
     * The url to navigate to when it is successful.
     */
    successUrl?: string;
    /**
     * The message to display when the action has started.
     */
    startMessage?: string;
    /**
     * The message to display when the action is cancelled.
     */
    cancelledMessage?: string;
    /**
     * The message to display when there is an error.
     */
    errorMessage?: string;
    /**
     * The message to display when it is successful.
     */
    successMessage?: string;
    /**
     * The props to pass to the snackbar when the action has started.
     */
    startOptions?: SnackbarProps;
    /**
     * The props to pass to the snackbar when the action is cancelled.
     */
    cancelledOptions?: SnackbarProps;
    /**
     * The props to pass to the snackbar when there is an error.
     */
    successOptions?: SnackbarProps;
    /**
     * The props to pass to the snackbar when it is successful.
     */
    errorOptions?: SnackbarProps;
    /**
     * A callback to execute when the action is cancelled.
     */
    cancelCallback?: (...args: any[]) => void;
}
/**
 * A unique key for each action.
 */
export interface ClusterState {
    [id: string]: ClusterAction;
}
export declare const initialState: ClusterState;
/** The amount of time to wait before allowing the action to be cancelled. */
export declare const CLUSTER_ACTION_GRACE_PERIOD = 5000;
/**
 * Uses the callback to execute an action and dispatches actions
 * to update the UI based on the result.
 *
 * Gives the user 5 seconds to cancel the action before executing it.
 */
export declare const executeClusterAction: import("@reduxjs/toolkit").AsyncThunk<string, CallbackAction, {
    state?: unknown;
    dispatch?: import("redux-thunk").ThunkDispatch<unknown, unknown, import("redux").UnknownAction>;
    extra?: unknown;
    rejectValue?: unknown;
    serializedErrorType?: unknown;
    pendingMeta?: unknown;
    fulfilledMeta?: unknown;
    rejectedMeta?: unknown;
}>;
export declare const updateClusterAction: import("@reduxjs/toolkit").ActionCreatorWithPayload<Partial<ClusterAction> & {
    id: string;
}, "clusterAction/updateClusterAction">, cancelClusterAction: import("@reduxjs/toolkit").ActionCreatorWithPayload<string, "clusterAction/cancelClusterAction">;
/**
 * Executes the callback action with the given options.
 */
export declare function clusterAction(callback: CallbackAction['callback'], actionOptions?: CallbackActionOptions): import("@reduxjs/toolkit").AsyncThunkAction<string, CallbackAction, {
    state?: unknown;
    dispatch?: import("redux-thunk").ThunkDispatch<unknown, unknown, import("redux").UnknownAction>;
    extra?: unknown;
    rejectValue?: unknown;
    serializedErrorType?: unknown;
    pendingMeta?: unknown;
    fulfilledMeta?: unknown;
    rejectedMeta?: unknown;
}>;
declare const _default: import("redux").Reducer<ClusterState>;
export default _default;
