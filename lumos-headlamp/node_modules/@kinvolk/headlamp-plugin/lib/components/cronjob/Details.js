import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Box, Button, Dialog, DialogActions, DialogContent, DialogContentText, DialogTitle, Input, InputLabel, } from '@mui/material';
import _ from 'lodash';
import { useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';
import { useDispatch } from 'react-redux';
import { useParams } from 'react-router-dom';
import { apply } from '../../lib/k8s/apiProxy';
import CronJob from '../../lib/k8s/cronJob';
import Job from '../../lib/k8s/job';
import { clusterAction } from '../../redux/clusterActionSlice';
import { ActionButton } from '../common';
import { DetailsGrid } from '../common/Resource';
import AuthVisible from '../common/Resource/AuthVisible';
import { JobsListRenderer } from '../job/List';
import { getLastScheduleTime, getSchedule } from './List';
function SpawnJobDialog(props) {
    const { cronJob, openJobDialog, setOpenJobDialog, applyFunc } = props;
    const { namespace } = useParams();
    const { t } = useTranslation(['translation']);
    const dispatch = useDispatch();
    // method to generate a unique string
    const uniqueString = () => {
        const timestamp = Date.now().toString(36);
        const randomNum = Math.random().toString(36).substr(2, 5);
        return `${timestamp}-${randomNum}`;
    };
    const job = _.cloneDeep(cronJob.spec.jobTemplate);
    const [jobName, setJobName] = useState(`${cronJob?.metadata?.name}-manual-spawn-${uniqueString()}`);
    // set all the fields that are assumed on the jobTemplate
    job.kind = 'Job';
    job.metadata = _.cloneDeep(job.metadata) || {};
    job.metadata.namespace = namespace;
    job.apiVersion = 'batch/v1';
    job.metadata.name = jobName;
    job.metadata.annotations = {
        ...job.metadata.annotations,
        'cronjob.kubernetes.io/instantiate': 'manual',
    };
    if (!!cronJob.jsonData) {
        job.metadata.ownerReferences = [
            {
                apiVersion: cronJob.jsonData.apiVersion,
                blockOwnerDeletion: true,
                controller: true,
                kind: cronJob.jsonData.kind,
                name: cronJob.metadata.name,
                uid: cronJob.metadata.uid,
            },
        ];
    }
    function handleClose() {
        setOpenJobDialog(false);
    }
    return (_jsxs(Dialog, { open: openJobDialog, onClose: handleClose, "aria-labelledby": "form-dialog-title", maxWidth: "sm", children: [_jsx(DialogTitle, { id: "form-dialog-title", children: t('translation|Spawn Job') }), _jsxs(DialogContent, { children: [_jsx(DialogContentText, { children: t('translation|This will trigger a new Job based on the CronJob {{ name }}', {
                            name,
                        }) }), _jsx(Box, { mb: 1, children: _jsx(InputLabel, { htmlFor: "name", children: t('translation|Job Name') }) }), _jsx(Input, { margin: "dense", id: "name", type: "text", fullWidth: true, value: jobName, onChange: e => {
                            setJobName(e.target.value);
                        } })] }), _jsxs(DialogActions, { children: [_jsx(Button, { onClick: handleClose, color: "primary", children: t('translation|Cancel') }), _jsx(Button, { onClick: () => {
                            handleClose();
                            dispatch(clusterAction(() => applyFunc(job), {
                                startMessage: t('translation|Spawning Job {{ newItemName }}…', {
                                    newItemName: job.metadata.name,
                                }),
                                successMessage: t('translation|Job {{ newItemName }} spawned', {
                                    newItemName: job.metadata.name,
                                }),
                                errorMessage: t('translation|Failed to spawn Job {{ newItemName }}', {
                                    newItemName: job.metadata.name,
                                }),
                            }));
                        }, color: "primary", children: t('translation|Spawn') })] })] }));
}
export default function CronJobDetails(props) {
    const params = useParams();
    const { name = params.name, namespace = params.namespace } = props;
    const { t, i18n } = useTranslation('glossary');
    const [jobs, jobsError] = Job.useList({ namespace });
    const [cronJob, setCronJob] = useState(null);
    const [isCronSuspended, setIsCronSuspended] = useState(false);
    const [isCheckingCronSuspendStatus, setIsCheckingCronSuspendStatus] = useState(true);
    const [openJobDialog, setOpenJobDialog] = useState(false);
    const dispatch = useDispatch();
    useEffect(() => {
        if (cronJob) {
            setIsCronSuspended(cronJob.spec.suspend);
            setIsCheckingCronSuspendStatus(false);
        }
    }, [cronJob]);
    function filterOwnedJobs(jobs) {
        if (!jobs) {
            return null;
        }
        return jobs.filter(job => {
            return !!job.metadata?.ownerReferences?.find((ownerRef) => ownerRef.kind === 'CronJob' && ownerRef.name === name);
        });
    }
    const ownedJobs = filterOwnedJobs(jobs);
    function applyFunc(newItem) {
        if (newItem.kind === 'CronJob') {
            setIsCheckingCronSuspendStatus(true);
        }
        else if (newItem.kind === 'Job') {
            setOpenJobDialog(false);
        }
        const result = apply(newItem).finally(() => {
            setIsCheckingCronSuspendStatus(false);
        });
        return result;
    }
    function PauseResumeAction() {
        if (!cronJob) {
            return null;
        }
        return (_jsx(ActionButton, { description: isCronSuspended ? t('translation|Resume') : t('translation|Suspend'), onClick: () => {
                handleCron(cronJob, !isCronSuspended);
            }, icon: isCronSuspended ? 'mdi:play-circle' : 'mdi:pause-circle', iconButtonProps: {
                disabled: isCheckingCronSuspendStatus,
            } }));
    }
    function handleCron(cronJob, suspend) {
        const clonedCronJob = _.cloneDeep(cronJob);
        clonedCronJob.spec.suspend = suspend;
        setIsCheckingCronSuspendStatus(true);
        dispatch(clusterAction(() => applyFunc(clonedCronJob.jsonData), {
            startMessage: suspend
                ? t('translation|Suspending CronJob {{ newItemName }}…', {
                    newItemName: clonedCronJob.metadata.name,
                })
                : t('translation|Resuming CronJob {{ newItemName }}…', {
                    newItemName: clonedCronJob.metadata.name,
                }),
            cancelledMessage: suspend
                ? t('translation|Cancelled suspending CronJob {{ newItemName }}.', {
                    newItemName: clonedCronJob.metadata.name,
                })
                : t('translation|Cancelled resuming CronJob {{ newItemName }}.', {
                    newItemName: clonedCronJob.metadata.name,
                }),
            successMessage: suspend
                ? t('translation|Suspended CronJob {{ newItemName }}.', {
                    newItemName: clonedCronJob.metadata.name,
                })
                : t('translation|Resumed CronJob {{ newItemName }}.', {
                    newItemName: clonedCronJob.metadata.name,
                }),
            errorMessage: suspend
                ? t('translation|Failed to suspend CronJob {{ newItemName }}.', {
                    newItemName: clonedCronJob.metadata.name,
                })
                : t('translation|Failed to resume CronJob {{ newItemName }}.', {
                    newItemName: clonedCronJob.metadata.name,
                }),
        }));
    }
    const actions = [];
    actions.push(cronJob && (_jsxs(AuthVisible, { authVerb: "create", item: Job, namespace: cronJob.getNamespace(), children: [_jsx(ActionButton, { description: t('translation|Spawn Job'), onClick: () => {
                    setOpenJobDialog(true);
                }, icon: "mdi:lightning-bolt-circle" }), openJobDialog && (_jsx(SpawnJobDialog, { cronJob: cronJob, openJobDialog: openJobDialog, setOpenJobDialog: setOpenJobDialog, applyFunc: applyFunc }))] })));
    actions.push(_jsx(AuthVisible, { authVerb: "update", item: cronJob, children: _jsx(PauseResumeAction, {}) }));
    return (_jsx(DetailsGrid, { resourceType: CronJob, name: name, namespace: namespace, withEvents: true, actions: actions, onResourceUpdate: cronJob => setCronJob(cronJob), extraInfo: item => item && [
            {
                name: t('Schedule'),
                value: getSchedule(item, i18n.language),
            },
            {
                name: t('translation|Suspend'),
                value: item.spec.suspend.toString(),
            },
            {
                name: t('Starting deadline'),
                value: `${item.spec.startingDeadlineSeconds}s`,
                hide: !item.spec.startingDeadlineSeconds,
            },
            {
                name: t('Last Schedule'),
                value: getLastScheduleTime(item),
            },
        ], extraSections: cronJob => cronJob && [
            _jsx(JobsListRenderer, { jobs: ownedJobs, error: CronJob.getErrorMessage(jobsError), hideColumns: ['namespace'], noNamespaceFilter: true }),
        ] }));
}
