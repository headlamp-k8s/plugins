import { jsx as _jsx } from "react/jsx-runtime";
import { useTranslation } from 'react-i18next';
import { useParams } from 'react-router-dom';
import { ConditionsSection, ContainersSection, DetailsGrid, MetadataDictGrid, OwnedPodsSection, } from '../common/Resource';
export default function WorkloadDetails(props) {
    const params = useParams();
    const { name = params.name, namespace = params.namespace } = props;
    const { workloadKind } = props;
    const { t } = useTranslation(['glossary', 'translation']);
    function renderUpdateStrategy(item) {
        if (!item?.spec?.strategy) {
            return null;
        }
        if (item.spec.strategy.type === 'RollingUpdate') {
            const rollingUpdate = item.spec.strategy.rollingUpdate;
            return t('RollingUpdate. Max unavailable: {{ maxUnavailable }}, max surge: {{ maxSurge }}', {
                maxUnavailable: rollingUpdate.maxUnavailable,
                maxSurge: rollingUpdate.maxSurge,
            });
        }
        return item.spec.strategy.type;
    }
    function showReplicas(item) {
        return (item.kind === 'Deployment' &&
            (item.spec?.status?.replicas !== undefined || item.spec?.replicas !== undefined));
    }
    function renderReplicas(item) {
        if (!showReplicas(item)) {
            return null;
        }
        let values = {
            [t('translation|Desired', { context: 'replicas' })]: item.spec.replicas,
            [t('translation|Ready', { context: 'replicas' })]: item.status.readyReplicas,
            [t('translation|Up to date', { context: 'replicas' })]: item.status.updatedReplicas,
            [t('translation|Available', { context: 'replicas' })]: item.status.availableReplicas,
            [t('translation|Total')]: item.status.replicas,
        };
        const validEntries = Object.entries(values).filter(([key]) => values[key] !== undefined);
        values = Object.fromEntries(validEntries);
        if (Object.values(values).length === 0) {
            return null;
        }
        return (_jsx(MetadataDictGrid, { dict: values, gridProps: {
                direction: 'column',
                justifyContent: 'flex-start',
                alignItems: 'flex-start',
            } }));
    }
    return (_jsx(DetailsGrid, { resourceType: workloadKind, name: name, withEvents: true, namespace: namespace, extraInfo: item => item && [
            {
                name: t('Strategy Type'),
                value: renderUpdateStrategy(item),
                hide: !item.spec.strategy,
            },
            {
                name: t('Selector'),
                value: item.spec.selector && (_jsx(MetadataDictGrid, { dict: item.spec.selector.matchLabels })),
            },
            {
                name: t('Replicas'),
                value: renderReplicas(item),
                hide: !showReplicas(item),
            },
        ], extraSections: item => item && [
            {
                id: 'headlamp.workload-conditions',
                section: _jsx(ConditionsSection, { resource: item?.jsonData }),
            },
            {
                id: 'headlamp.workload-owned-pods',
                section: _jsx(OwnedPodsSection, { resource: item?.jsonData }),
            },
            {
                id: 'headlamp.workload-containers',
                section: _jsx(ContainersSection, { resource: item?.jsonData }),
            },
        ] }));
}
