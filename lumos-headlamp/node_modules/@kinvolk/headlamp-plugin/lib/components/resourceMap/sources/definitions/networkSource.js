import { jsx as _jsx } from "react/jsx-runtime";
import { Icon } from '@iconify/react';
import { useMemo } from 'react';
import Endpoints from '../../../../lib/k8s/endpoints';
import Ingress from '../../../../lib/k8s/ingress';
import IngressClass from '../../../../lib/k8s/ingressClass';
import NetworkPolicy from '../../../../lib/k8s/networkpolicy';
import Pod from '../../../../lib/k8s/pod';
import Secret from '../../../../lib/k8s/secret';
import Service from '../../../../lib/k8s/service';
import { getKindGroupColor, KubeIcon } from '../../kubeIcon/KubeIcon';
import { makeKubeObjectNode, makeKubeToKubeEdge } from '../GraphSources';
import { matchesSelector } from './workloadSource';
const serviceSource = {
    id: 'services',
    label: 'Services',
    icon: _jsx(KubeIcon, { kind: 'Service' }),
    useData() {
        const [services] = Service.useList();
        const [pods] = Pod.useList();
        return useMemo(() => {
            if (!services || !pods)
                return null;
            const edges = [];
            services.forEach(service => {
                const matchingPods = pods.filter(matchesSelector(service.spec.selector));
                matchingPods?.forEach(pod => {
                    edges.push(makeKubeToKubeEdge(service, pod));
                });
            });
            return {
                edges,
                nodes: services.map(makeKubeObjectNode) ?? [],
            };
        }, [services, pods]);
    },
};
const endpointsSource = {
    id: 'endpoints',
    label: 'Endpoints',
    icon: _jsx(KubeIcon, { kind: "Endpoint" }),
    useData() {
        const [endpoints] = Endpoints.useList();
        const [services] = Service.useList();
        return useMemo(() => {
            const nodes = endpoints?.map(makeKubeObjectNode) ?? [];
            const edges = [];
            services?.forEach(service => {
                endpoints?.forEach(endpoint => {
                    if (endpoint.getName() === service.getName()) {
                        edges.push(makeKubeToKubeEdge(service, endpoint));
                    }
                });
            });
            return { nodes, edges };
        }, [endpoints, services]);
    },
};
const ingressListSource = {
    id: 'ingressList',
    label: 'Ingress',
    icon: _jsx(KubeIcon, { kind: 'Ingress' }),
    useData() {
        const [ingresses] = Ingress.useList();
        const [services] = Service.useList();
        const [secrets] = Secret.useList();
        return useMemo(() => {
            if (!ingresses || !services || !secrets)
                return null;
            const edges = [];
            ingresses.forEach(ingress => {
                ingress.spec.rules.forEach((rule) => {
                    rule.http.paths.forEach(path => {
                        const service = services.find(service => service.metadata.name === path?.backend?.service?.name);
                        if (service) {
                            edges.push(makeKubeToKubeEdge(service, ingress));
                        }
                    });
                });
                ingress.spec.tls?.forEach(tls => {
                    if (tls.secretName) {
                        const secret = secrets.find(secret => secret.metadata.name === tls.secretName);
                        if (secret) {
                            edges.push(makeKubeToKubeEdge(secret, ingress));
                        }
                    }
                });
            });
            return {
                edges,
                nodes: ingresses.map(makeKubeObjectNode) ?? [],
            };
        }, [ingresses, services, secrets]);
    },
};
const networkPoliciesSource = {
    id: 'networkPolicies',
    label: 'Network Policies',
    icon: _jsx(KubeIcon, { kind: "NetworkPolicy" }),
    useData() {
        const [networkPolicies] = NetworkPolicy.useList();
        const [pods] = Pod.useList();
        return useMemo(() => {
            if (!networkPolicies || !pods)
                return null;
            const edges = [];
            networkPolicies.forEach(np => {
                const matchingPods = pods.filter(matchesSelector(np.jsonData.spec.podSelector.matchLabels));
                matchingPods?.forEach(pod => {
                    edges.push(makeKubeToKubeEdge(np, pod));
                });
            });
            return {
                nodes: networkPolicies.map(makeKubeObjectNode) ?? [],
                edges,
            };
        }, [networkPolicies, pods]);
    },
};
const ingressClassesSource = {
    id: 'ingressClasses',
    label: 'Ingress Classes',
    icon: _jsx(KubeIcon, { kind: "Ingress" }),
    useData() {
        const [ingressClasses] = IngressClass.useList();
        return useMemo(() => {
            return {
                nodes: ingressClasses?.map(makeKubeObjectNode) ?? [],
                edges: [],
            };
        }, [ingressClasses]);
    },
};
export const networkSource = {
    id: 'network',
    label: 'Network',
    icon: _jsx(Icon, { icon: "mdi:lan", width: "100%", height: "100%", color: getKindGroupColor('network') }),
    sources: [
        serviceSource,
        endpointsSource,
        ingressListSource,
        ingressClassesSource,
        networkPoliciesSource,
    ],
};
