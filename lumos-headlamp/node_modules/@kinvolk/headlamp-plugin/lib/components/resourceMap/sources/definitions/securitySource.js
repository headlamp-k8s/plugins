import { jsx as _jsx } from "react/jsx-runtime";
import { Icon } from '@iconify/react';
import { useMemo } from 'react';
import DaemonSet from '../../../../lib/k8s/daemonSet';
import Deployment from '../../../../lib/k8s/deployment';
import Role from '../../../../lib/k8s/role';
import RoleBinding from '../../../../lib/k8s/roleBinding';
import ServiceAccount from '../../../../lib/k8s/serviceAccount';
import { getKindGroupColor, KubeIcon } from '../../kubeIcon/KubeIcon';
import { makeKubeObjectNode, makeKubeToKubeEdge } from '../GraphSources';
const rolesSource = {
    id: 'roles',
    label: 'Roles',
    icon: _jsx(KubeIcon, { kind: "Role" }),
    useData() {
        const [roles] = Role.useList();
        return useMemo(() => roles
            ? {
                nodes: roles.map(makeKubeObjectNode) ?? [],
            }
            : null, [roles]);
    },
};
const roleBindingsSource = {
    id: 'roleBindings',
    label: 'Role Bindings',
    icon: _jsx(KubeIcon, { kind: "RoleBinding" }),
    useData() {
        const [roleBindings] = RoleBinding.useList();
        const [roles] = Role.useList();
        const [serviceAccounts] = ServiceAccount.useList();
        return useMemo(() => {
            if (!roleBindings || !roles || !serviceAccounts)
                return null;
            const edges = [];
            roleBindings.forEach(roleBinding => {
                const role = roles.find(role => role.metadata.name === roleBinding.roleRef.name);
                if (role) {
                    edges.push(makeKubeToKubeEdge(role, roleBinding));
                }
                // subject
                roleBinding.subjects.forEach(subject => {
                    if (subject.kind === 'ServiceAccount') {
                        const sa = serviceAccounts.find(sa => sa.metadata.name === subject.name);
                        if (sa) {
                            edges.push(makeKubeToKubeEdge(sa, roleBinding));
                        }
                    }
                });
            });
            return {
                nodes: roleBindings.map(makeKubeObjectNode) ?? [],
                edges,
            };
        }, [roleBindings, roles, serviceAccounts]);
    },
};
const serviceAccountsSource = {
    id: 'serviceAccounts',
    label: 'Service Accounts',
    icon: _jsx(KubeIcon, { kind: "ServiceAccount" }),
    useData() {
        const [serviceAccounts] = ServiceAccount.useList();
        const [deployments] = Deployment.useList();
        const [daemonSets] = DaemonSet.useList();
        return useMemo(() => {
            if (!serviceAccounts || !deployments || !daemonSets)
                return null;
            const edges = [];
            serviceAccounts.forEach(sa => {
                const matchingDeployments = deployments?.filter(d => (d.spec?.template?.spec?.serviceAccountName ?? 'default') === sa.metadata.name &&
                    d.metadata.namespace === sa.metadata.namespace);
                matchingDeployments.forEach(d => {
                    edges.push(makeKubeToKubeEdge(sa, d));
                });
                daemonSets
                    ?.filter(d => (d.spec?.template?.spec?.serviceAccountName ?? 'default') === sa.metadata.name &&
                    d.metadata.namespace === sa.metadata.namespace)
                    .forEach(d => edges.push(makeKubeToKubeEdge(sa, d)));
            });
            return {
                edges,
                nodes: serviceAccounts.map(makeKubeObjectNode) ?? [],
            };
        }, [serviceAccounts, deployments, daemonSets]);
    },
};
export const securitySource = {
    id: 'security',
    label: 'Security',
    isEnabledByDefault: false,
    icon: _jsx(Icon, { icon: "mdi:lock", width: "100%", height: "100%", color: getKindGroupColor('security') }),
    sources: [serviceAccountsSource, rolesSource, roleBindingsSource],
};
