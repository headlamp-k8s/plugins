import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import '@xyflow/react/dist/base.css';
import './GraphView.css';
import { Icon } from '@iconify/react';
import { Box, Chip, ThemeProvider } from '@mui/material';
import { getNodesBounds, Panel, ReactFlowProvider, useReactFlow, useStore, } from '@xyflow/react';
import { createContext, StrictMode, useCallback, useContext, useEffect, useLayoutEffect, useMemo, useRef, useState, } from 'react';
import { useTranslation } from 'react-i18next';
import { useTypedSelector } from '../../redux/reducers/reducers';
import { NamespacesAutocomplete } from '../common';
import { GraphNodeDetails } from './details/GraphNodeDetails';
import { filterGraph } from './graph/graphFiltering';
import { collapseGraph, findGroupContaining, getGraphSize, getParentNode, groupGraph, } from './graph/graphGrouping';
import { applyGraphLayout } from './graph/graphLayout';
import { isGroup } from './graph/graphModel';
import { GraphControlButton } from './GraphControls';
import { GraphRenderer } from './GraphRenderer';
import { useNodeHighlight } from './NodeHighlight';
import { ResourceSearch } from './search/ResourceSearch';
import { SelectionBreadcrumbs } from './SelectionBreadcrumbs';
import { allSources, GraphSourceManager, useSources } from './sources/GraphSources';
import { GraphSourcesView } from './sources/GraphSourcesView';
import { useQueryParamsState } from './useQueryParamsState';
export const GraphViewContext = createContext({});
export const useGraphView = () => useContext(GraphViewContext);
const defaultFiltersValue = [];
function GraphViewContent({ height, defaultNodeSelection, defaultSources = allSources, defaultFilters = defaultFiltersValue, }) {
    const { t } = useTranslation();
    // List of selected namespaces
    const namespaces = useTypedSelector(state => state.filter).namespaces;
    // Filters
    const [hasErrorsFilter, setHasErrorsFilter] = useState(false);
    // Grouping state
    const [groupBy, setGroupBy] = useQueryParamsState('group', 'namespace');
    // Keep track if user moved the viewport
    const viewportMovedRef = useRef(false);
    // ID of the selected Node, undefined means nothing is selected
    const [selectedNodeId, _setSelectedNodeId] = useQueryParamsState('node', defaultNodeSelection);
    const setSelectedNodeId = useCallback((id) => {
        if (id === 'root') {
            _setSelectedNodeId(undefined);
            return;
        }
        _setSelectedNodeId(id);
    }, [_setSelectedNodeId]);
    // Expand all groups state
    const [expandAll, setExpandAll] = useState(false);
    // Load source data
    const { nodes, edges, selectedSources, sourceData, isLoading, toggleSelection } = useSources();
    // Graph with applied layout, has sizes and positions for all elements
    const [layoutedGraph, setLayoutedGraph] = useState({
        nodes: [],
        edges: [],
    });
    const flow = useReactFlow();
    // Apply filters
    const filteredGraph = useMemo(() => {
        const filters = [...defaultFilters];
        if (hasErrorsFilter) {
            filters.push({ type: 'hasErrors' });
        }
        if (namespaces) {
            filters.push({ type: 'namespace', namespaces });
        }
        return filterGraph(nodes, edges, filters);
    }, [nodes, edges, hasErrorsFilter, namespaces, defaultFilters]);
    // Group the graph
    const { visibleGraph, fullGraph } = useMemo(() => {
        const graph = groupGraph(filteredGraph.nodes, filteredGraph.edges, {
            groupBy,
        });
        const visibleGraph = collapseGraph(graph, { selectedNodeId, expandAll });
        return { visibleGraph, fullGraph: graph };
    }, [filteredGraph, groupBy, selectedNodeId, expandAll]);
    // Apply layout to visible graph
    const aspectRatio = useStore(it => it.width / it.height);
    const reactFlowWidth = useStore(it => it.width);
    const reactFlowHeight = useStore(it => it.height);
    /**
     * Zooms the viewport to 100% zoom level
     * It will center the nodes if they fit into view
     * Or if they don't fit it:
     *  - align to top if they don't fit vertically
     *  - align to left if they don't fit horizontally
     */
    const zoomTo100 = useCallback((nodes) => {
        const bounds = getNodesBounds(nodes);
        const defaultViewportPaddingPx = 50;
        const topLeftOrigin = { x: defaultViewportPaddingPx, y: defaultViewportPaddingPx };
        const centerOrigin = {
            x: reactFlowWidth / 2 - bounds.width / 2,
            y: reactFlowHeight / 2 - bounds.height / 2,
        };
        const xFits = bounds.width + defaultViewportPaddingPx * 2 <= reactFlowWidth;
        const yFits = bounds.height + defaultViewportPaddingPx * 2 <= reactFlowHeight;
        const defaultZoomViewport = {
            x: xFits ? centerOrigin.x : topLeftOrigin.x,
            y: yFits ? centerOrigin.y : topLeftOrigin.y,
            zoom: 1,
        };
        flow.setViewport(defaultZoomViewport);
    }, [flow, reactFlowWidth, reactFlowHeight]);
    useEffect(() => {
        applyGraphLayout(visibleGraph, aspectRatio).then(layout => {
            setLayoutedGraph(layout);
            // Only fit bounds when user hasn't moved viewport manually
            if (!viewportMovedRef.current) {
                zoomTo100(layout.nodes);
            }
        });
    }, [visibleGraph, aspectRatio, zoomTo100]);
    // Reset after view change
    useLayoutEffect(() => {
        viewportMovedRef.current = false;
    }, [selectedNodeId, groupBy, expandAll]);
    const selectedNode = useMemo(() => nodes.find((it) => it.id === selectedNodeId), [selectedNodeId, nodes]);
    const selectedGroup = useMemo(() => {
        if (selectedNodeId) {
            return findGroupContaining(visibleGraph, selectedNodeId);
        }
    }, [selectedNodeId, visibleGraph, findGroupContaining]);
    const highlights = useNodeHighlight(selectedNodeId);
    const graphSize = getGraphSize(visibleGraph);
    useEffect(() => {
        if (expandAll && graphSize > 50) {
            setExpandAll(false);
        }
    }, [graphSize]);
    const contextValue = useMemo(() => ({ nodeSelection: selectedNodeId, highlights, setNodeSelection: setSelectedNodeId }), [selectedNodeId, setSelectedNodeId, highlights]);
    return (_jsx(GraphViewContext.Provider, { value: contextValue, children: _jsxs(Box, { sx: {
                position: 'relative',
                height: height ?? '800px',
                display: 'flex',
                flexDirection: 'row',
                flex: 1,
            }, children: [_jsx(CustomThemeProvider, { children: _jsxs(Box, { sx: {
                            overflow: 'hidden',
                            display: 'flex',
                            flexDirection: 'column',
                            position: 'relative',
                            flexGrow: 1,
                            background: '#00000002',
                        }, children: [_jsxs(Box, { padding: 2, pb: 0, display: "flex", gap: 1, alignItems: "center", mb: 1, flexWrap: "wrap", children: [_jsx(ResourceSearch, { resources: nodes.flatMap(it => it.type === 'kubeObject' ? [it.data.resource] : []), onSearch: resource => {
                                            setSelectedNodeId(resource.metadata.uid);
                                        } }), _jsx(NamespacesAutocomplete, {}), _jsx(GraphSourcesView, { sources: defaultSources, selectedSources: selectedSources, toggleSource: toggleSelection, sourceData: sourceData ?? new Map() }), namespaces.size !== 1 && (_jsx(ChipToggleButton, { label: t('Group By: {{ name }}', { name: t('Namespace') }), isActive: groupBy === 'namespace', onClick: () => setGroupBy(groupBy === 'namespace' ? undefined : 'namespace') })), _jsx(ChipToggleButton, { label: t('Group By: {{ name }}', { name: t('Instance') }), isActive: groupBy === 'instance', onClick: () => setGroupBy(groupBy === 'instance' ? undefined : 'instance') }), _jsx(ChipToggleButton, { label: t('Group By: {{ name }}', { name: t('Node') }), isActive: groupBy === 'node', onClick: () => setGroupBy(groupBy === 'node' ? undefined : 'node') }), _jsx(ChipToggleButton, { label: t('Status: Error or Warning'), isActive: hasErrorsFilter, onClick: () => setHasErrorsFilter(!hasErrorsFilter) }), graphSize < 50 && (_jsx(ChipToggleButton, { label: t('Expand All'), isActive: expandAll, onClick: () => setExpandAll(it => !it) }))] }), _jsx("div", { style: { flexGrow: 1 }, children: _jsx(GraphRenderer, { nodes: layoutedGraph.nodes, edges: layoutedGraph.edges, isLoading: isLoading, onMoveStart: e => {
                                        if (e === null)
                                            return;
                                        viewportMovedRef.current = true;
                                    }, onBackgroundClick: () => {
                                        // When node is selected (side panel is open) and user clicks on the background
                                        // We should select parent node, closing the side panel
                                        if (selectedNode && !isGroup(selectedNode)) {
                                            setSelectedNodeId(getParentNode(fullGraph, selectedNode.id)?.id);
                                        }
                                    }, controlActions: _jsx(GraphControlButton, { title: t('Zoom to 100%'), onClick: () => zoomTo100(layoutedGraph.nodes), children: "100%" }), children: _jsx(Panel, { position: "top-left", children: selectedGroup && (_jsx(SelectionBreadcrumbs, { graph: fullGraph, selectedNodeId: selectedNodeId, onNodeClick: id => setSelectedNodeId(id) })) }) }) })] }) }), selectedNode && (_jsx(GraphNodeDetails, { node: selectedNode, close: () => {
                        setSelectedNodeId(selectedGroup?.id ?? defaultNodeSelection);
                    } }))] }) }));
}
function ChipToggleButton({ label, isActive, onClick, }) {
    return (_jsx(Chip, { label: label, color: isActive ? 'primary' : undefined, variant: isActive ? 'filled' : 'outlined', icon: isActive ? _jsx(Icon, { icon: "mdi:check" }) : undefined, onClick: onClick, sx: {
            lineHeight: '1',
        } }));
}
function CustomThemeProvider({ children }) {
    return (_jsx(ThemeProvider, { theme: (outer) => ({
            ...outer,
            palette: outer.palette.mode === 'light'
                ? {
                    ...outer.palette,
                    primary: {
                        main: '#555',
                        contrastText: '#fff',
                        light: '#666',
                        dark: '#444',
                    },
                }
                : {
                    ...outer.palette,
                    primary: {
                        main: '#fafafa',
                        contrastText: '#444',
                        light: '#fff',
                        dark: '#f0f0f0',
                    },
                },
            components: {},
        }), children: children }));
}
/**
 * Renders Map of Kubernetes resources
 *
 * @param params - Map parameters
 * @returns
 */
export function GraphView(props) {
    return (_jsx(StrictMode, { children: _jsx(ReactFlowProvider, { children: _jsx(GraphSourceManager, { sources: props.defaultSources ?? allSources, children: _jsx(GraphViewContent, { ...props }) }) }) }));
}
