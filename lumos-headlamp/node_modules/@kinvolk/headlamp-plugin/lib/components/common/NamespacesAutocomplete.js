import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Icon } from '@iconify/react';
import Autocomplete from '@mui/material/Autocomplete';
import Box from '@mui/material/Box';
import Checkbox from '@mui/material/Checkbox';
import { useTheme } from '@mui/material/styles';
import TextField from '@mui/material/TextField';
import Typography from '@mui/material/Typography';
import React, { useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { useDispatch } from 'react-redux';
import { useHistory, useLocation } from 'react-router-dom';
import helpers, { addQuery } from '../../helpers';
import { useCluster } from '../../lib/k8s';
import Namespace from '../../lib/k8s/namespace';
import { setNamespaceFilter } from '../../redux/filterSlice';
import { useTypedSelector } from '../../redux/reducers/reducers';
export function PureNamespacesAutocomplete({ namespaceNames, onChange: onChangeFromProps, filter, }) {
    const theme = useTheme();
    const { t } = useTranslation(['glossary', 'translation']);
    const [namespaceInput, setNamespaceInput] = React.useState('');
    const maxNamespacesChars = 12;
    const onInputChange = (event, value, reason) => {
        // For some reason, the AutoComplete component resets the text after a short
        // delay, so we need to avoid that or the user won't be able to edit/use what they type.
        if (reason !== 'reset') {
            setNamespaceInput(value);
        }
    };
    const onChange = (event, newValue) => {
        // Now we reset the input so it won't show next to the selected namespaces.
        setNamespaceInput('');
        onChangeFromProps(event, newValue);
    };
    return (_jsx(Autocomplete, { multiple: true, id: "namespaces-filter", autoComplete: true, openOnFocus: true, options: namespaceNames, onChange: onChange, onInputChange: onInputChange, inputValue: namespaceInput, 
        // We reverse the namespaces so the last chosen appear as the first in the label. This
        // is useful since the label is ellipsized and this we get to see it change.
        value: [...filter.namespaces.values()].reverse(), renderOption: (props, option, { selected }) => (_jsxs("li", { ...props, children: [_jsx(Checkbox, { icon: _jsx(Icon, { icon: "mdi:checkbox-blank-outline" }), checkedIcon: _jsx(Icon, { icon: "mdi:check-box-outline" }), style: {
                        color: selected ? theme.palette.primary.main : theme.palette.text.primary,
                    }, checked: selected }), option] })), renderTags: (tags) => {
            if (tags.length === 0) {
                return _jsx(Typography, { variant: "body2", children: t('translation|All namespaces') });
            }
            let namespacesToShow = tags[0];
            const joiner = ', ';
            const joinerLength = joiner.length;
            let joinnedNamespaces = 1;
            tags.slice(1).forEach(tag => {
                if (namespacesToShow.length + tag.length + joinerLength <= maxNamespacesChars) {
                    namespacesToShow += joiner + tag;
                    joinnedNamespaces++;
                }
            });
            return (_jsxs(Typography, { style: { overflowWrap: 'anywhere' }, ml: 1, children: [namespacesToShow.length > maxNamespacesChars
                        ? namespacesToShow.slice(0, maxNamespacesChars) + 'â€¦'
                        : namespacesToShow, tags.length > joinnedNamespaces && (_jsxs(_Fragment, { children: [_jsx("span", { children: ",\u00A0" }), _jsx("b", { children: `+${tags.length - joinnedNamespaces}` })] }))] }));
        }, renderInput: params => (_jsx(Box, { width: "15rem", children: _jsx(TextField, { ...params, variant: "outlined", size: "small", label: t('Namespaces'), fullWidth: true, InputLabelProps: { shrink: true }, style: { marginTop: 0 }, placeholder: [...filter.namespaces.values()].length > 0 ? '' : 'Filter' }) })) }));
}
export function NamespacesAutocomplete() {
    const history = useHistory();
    const location = useLocation();
    const dispatch = useDispatch();
    const filter = useTypedSelector(state => state.filter);
    const cluster = useCluster();
    const [namespaceNames, setNamespaceNames] = React.useState([]);
    React.useEffect(() => {
        const settings = helpers.loadClusterSettings(cluster || '');
        const allowedNamespaces = settings?.allowedNamespaces || [];
        if (allowedNamespaces.length > 0) {
            setNamespaceNames(allowedNamespaces);
        }
    }, [cluster]);
    const onChange = (event, newValue) => {
        addQuery({ namespace: newValue.join(' ') }, { namespace: '' }, history, location, '');
        dispatch(setNamespaceFilter(newValue));
    };
    return namespaceNames.length > 0 ? (_jsx(PureNamespacesAutocomplete, { namespaceNames: namespaceNames, onChange: onChange, filter: filter })) : (_jsx(NamespacesFromClusterAutocomplete, { onChange: onChange, filter: filter }));
}
function NamespacesFromClusterAutocomplete(props) {
    const [namespacesList] = Namespace.useList();
    const namespaceNames = useMemo(() => namespacesList?.map(namespace => namespace.metadata.name) ?? [], [namespacesList]);
    return _jsx(PureNamespacesAutocomplete, { namespaceNames: namespaceNames, ...props });
}
