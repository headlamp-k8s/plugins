import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { MenuItem } from '@mui/material';
import { useTheme } from '@mui/material/styles';
import { MRT_FilterFns } from 'material-react-table';
import { useEffect, useMemo, useRef, useState } from 'react';
import { useTranslation } from 'react-i18next';
import helpers from '../../../helpers';
import { useClusterGroup } from '../../../lib/k8s';
import { useFilterFunc } from '../../../lib/util';
import { DefaultHeaderAction } from '../../../redux/actionButtonsSlice';
import { HeadlampEventType, useEventCallback } from '../../../redux/headlampEventSlice';
import { useTypedSelector } from '../../../redux/reducers/reducers';
import { useSettings } from '../../App/Settings/hook';
import { ClusterGroupErrorMessage } from '../../cluster/ClusterGroupErrorMessage';
import { DateLabel } from '../Label';
import Link from '../Link';
import Table from '../Table';
import DeleteButton from './DeleteButton';
import EditButton from './EditButton';
import { RestartButton } from './RestartButton';
import ScaleButton from './ScaleButton';
import ViewButton from './ViewButton';
export default function ResourceTable(props) {
    const { clusterErrors } = props;
    if (!!props.resourceClass) {
        const { resourceClass, ...otherProps } = props;
        return _jsx(TableFromResourceClass, { resourceClass: resourceClass, ...otherProps });
    }
    return (_jsxs(_Fragment, { children: [_jsx(ClusterGroupErrorMessage, { clusterErrors: clusterErrors ? clusterErrors : undefined }), _jsx(ResourceTableContent, { ...props })] }));
}
function TableFromResourceClass(props) {
    const { resourceClass, id, ...otherProps } = props;
    const { items, error, clusterErrors } = resourceClass.useList();
    // throttle the update of the table to once per second
    const throttledItems = useThrottle(items, 1000);
    const dispatchHeadlampEvent = useEventCallback(HeadlampEventType.LIST_VIEW);
    useEffect(() => {
        dispatchHeadlampEvent({
            resources: items,
            resourceKind: resourceClass.className,
            error: error || undefined,
        });
    }, [items, error]);
    return (_jsx(ResourceTableContent, { errorMessage: resourceClass.getErrorMessage(error), id: id || `headlamp-${resourceClass.pluralName}`, ...otherProps, data: throttledItems, clusterErrors: clusterErrors }));
}
/**
 * Here we figure out which columns are visible and not visible
 * We can control it using show property in the columns prop {@link ResourceTableColumn}
 * And when user manually changes visibility it is saved to localStorage
 */
function initColumnVisibilityState(columns, tableId) {
    const visibility = {};
    // Apply default visibility we got from the props
    columns.forEach((col, index) => {
        if (typeof col === 'string')
            return;
        if ('show' in col) {
            visibility[col.id ?? String(index)] = col.show ?? true;
        }
    });
    // Load and apply persisted settings from local storage
    if (tableId) {
        const localTableSettins = helpers.loadTableSettings(tableId);
        localTableSettins.forEach(({ id, show }) => (visibility[id] = show));
    }
    return visibility;
}
// By default MRT passes row object to the sorting function but we only need the original item
function sortingFn(sortFn) {
    if (!sortFn)
        return undefined;
    return (a, b) => sortFn(a.original, b.original);
}
/**
 * Returns a throttled version of the input value.
 *
 * @param value - The value to be throttled.
 * @param interval - The interval in milliseconds to throttle the value.
 * @returns The throttled value.
 */
export function useThrottle(value, interval = 1000) {
    const [throttledValue, setThrottledValue] = useState(value);
    const lastEffected = useRef(Date.now() + interval);
    // Ensure we don't throttle holding the loading null or undefined value before
    // real data comes in. Otherwise we could wait up to interval milliseconds
    // before we update the throttled value.
    //
    //   numEffected == 0,  null, or undefined whilst loading.
    //   numEffected == 1,  real data.
    const numEffected = useRef(0);
    useEffect(() => {
        const now = Date.now();
        if (now >= lastEffected.current + interval || numEffected.current < 2) {
            numEffected.current = numEffected.current + 1;
            lastEffected.current = now;
            setThrottledValue(value);
        }
        else {
            const id = window.setTimeout(() => {
                lastEffected.current = now;
                setThrottledValue(value);
            }, interval);
            return () => window.clearTimeout(id);
        }
    }, [value, interval]);
    return throttledValue;
}
function ResourceTableContent(props) {
    const { columns, defaultSortingColumn, id, noProcessing = false, hideColumns = [], filterFunction, errorMessage, reflectInURL, data, defaultGlobalFilter, actions, enableRowActions = false, } = props;
    const { t } = useTranslation(['glossary', 'translation']);
    const theme = useTheme();
    const storeRowsPerPageOptions = useSettings('tableRowsPerPageOptions');
    const clusters = useClusterGroup();
    const tableProcessors = useTypedSelector(state => state.resourceTable.tableColumnsProcessors);
    const defaultFilterFunc = useFilterFunc();
    const [columnVisibility, setColumnVisibility] = useState(() => initColumnVisibilityState(columns, id));
    const [tableSettings] = useState(!!id ? helpers.loadTableSettings(id) : []);
    const [allColumns, sort] = useMemo(() => {
        let processedColumns = columns;
        if (!noProcessing) {
            tableProcessors.forEach(processorInfo => {
                console.debug('Processing columns with processor: ', processorInfo.id, '...');
                processedColumns =
                    processorInfo.processor({ id: id || '', columns: processedColumns }) || [];
            });
        }
        function removeClusterColIfNeeded(cols) {
            return cols.filter(col => clusters.length > 1 || col !== 'cluster');
        }
        const allColumns = removeClusterColIfNeeded(processedColumns)
            .map((col, index) => {
            const indexId = String(index);
            if (typeof col !== 'string') {
                const column = col;
                const sort = column.sort ?? true;
                const mrtColumn = {
                    id: column.id ?? indexId,
                    header: column.label,
                    filterVariant: column.filterVariant,
                    enableMultiSort: !!sort,
                    enableSorting: !!sort,
                    enableColumnFilter: !column.disableFiltering,
                    muiTableBodyCellProps: {
                        ...column.cellProps,
                        // Make sure column don't override width, it'll mess up the layout
                        // the layout is controlled only through the gridTemplate property
                        sx: { ...(column.cellProps?.sx ?? {}), width: 'unset', minWidth: 'unset' },
                    },
                    gridTemplate: column.gridTemplate ?? 1,
                    filterSelectOptions: column.filterSelectOptions,
                };
                if ('getValue' in column) {
                    mrtColumn.accessorFn = item => column.getValue?.(item) ?? '';
                }
                else if ('getter' in column) {
                    mrtColumn.accessorFn = column.getter;
                }
                else {
                    mrtColumn.accessorFn = (item) => item[column.datum];
                }
                if ('render' in column) {
                    mrtColumn.Cell = ({ row }) => column.render?.(row.original) ?? null;
                }
                if (sort && typeof sort === 'function') {
                    mrtColumn.sortingFn = sortingFn(sort);
                }
                return mrtColumn;
            }
            switch (col) {
                case 'name':
                    return {
                        id: 'name',
                        header: t('translation|Name'),
                        gridTemplate: 1.5,
                        accessorFn: (item) => item.metadata.name,
                        Cell: ({ row }) => row.original && _jsx(Link, { kubeObject: row.original }),
                    };
                case 'age':
                    return {
                        id: 'age',
                        header: t('translation|Age'),
                        gridTemplate: 'min-content',
                        accessorFn: (item) => -new Date(item.metadata.creationTimestamp).getTime(),
                        enableColumnFilter: false,
                        muiTableBodyCellProps: {
                            align: 'right',
                        },
                        Cell: ({ row }) => row.original && (_jsx(DateLabel, { date: row.original.metadata.creationTimestamp, format: "mini", iconProps: { color: theme.palette.text.primary } })),
                    };
                case 'namespace':
                    return {
                        id: 'namespace',
                        header: t('glossary|Namespace'),
                        accessorFn: (item) => item.getNamespace(),
                        filterVariant: 'multi-select',
                        Cell: ({ row }) => row.original?.getNamespace() ? (_jsx(Link, { routeName: "namespace", params: { name: row.original.getNamespace() }, children: row.original.getNamespace() })) : (''),
                    };
                case 'cluster':
                    return {
                        id: 'cluster',
                        header: t('glossary|Cluster'),
                        accessorFn: (resource) => resource.cluster,
                    };
                case 'type':
                case 'kind':
                    return {
                        id: 'kind',
                        header: t('translation|Type'),
                        accessorFn: (resource) => String(resource?.kind),
                        filterVariant: 'multi-select',
                    };
                default:
                    throw new Error(`Unknown column: ${col}`);
            }
        })
            .filter(col => !hideColumns?.includes(col.id ?? ''));
        let sort = undefined;
        const sortingColumn = defaultSortingColumn ?? allColumns.find(it => it.id === 'age');
        if (sortingColumn) {
            sort = {
                id: sortingColumn.id,
                desc: false,
            };
        }
        return [allColumns, sort];
    }, [
        columns,
        hideColumns,
        id,
        noProcessing,
        defaultSortingColumn,
        tableProcessors,
        tableSettings,
    ]);
    const defaultActions = [
        {
            id: DefaultHeaderAction.RESTART,
            action: ({ item }) => _jsx(RestartButton, { item: item, buttonStyle: "menu" }),
        },
        {
            id: DefaultHeaderAction.SCALE,
            action: ({ item }) => _jsx(ScaleButton, { item: item, buttonStyle: "menu" }),
        },
        {
            id: DefaultHeaderAction.EDIT,
            action: ({ item, closeMenu }) => (_jsx(EditButton, { item: item, buttonStyle: "menu", afterConfirm: closeMenu })),
        },
        {
            id: DefaultHeaderAction.VIEW,
            action: ({ item }) => _jsx(ViewButton, { item: item, buttonStyle: "menu" }),
        },
        {
            id: DefaultHeaderAction.DELETE,
            action: ({ item, closeMenu }) => (_jsx(DeleteButton, { item: item, buttonStyle: "menu", afterConfirm: closeMenu })),
        },
    ];
    let hAccs = [];
    if (actions !== undefined && actions !== null) {
        hAccs = actions;
    }
    const actionsProcessed = [...hAccs, ...defaultActions];
    const renderRowActionMenuItems = useMemo(() => {
        if (actionsProcessed.length === 0) {
            return null;
        }
        return ({ closeMenu, row }) => {
            return actionsProcessed.map(action => {
                if (action.action === undefined || action.action === null) {
                    return _jsx(MenuItem, {});
                }
                return action.action({ item: row.original, closeMenu });
            });
        };
    }, [actionsProcessed]);
    function onColumnsVisibilityChange(updater) {
        setColumnVisibility(oldCols => {
            const newCols = updater(oldCols);
            if (!!id) {
                const colsToStore = Object.entries(newCols).map(([id, show]) => ({
                    id,
                    show: (show ?? true),
                }));
                helpers.storeTableSettings(id, colsToStore);
            }
            return newCols;
        });
    }
    const initialState = {
        sorting: sort ? [sort] : undefined,
    };
    if (defaultGlobalFilter) {
        initialState.globalFilter = defaultGlobalFilter;
        initialState.showGlobalFilter = true;
    }
    const filterFunc = filterFunction ?? defaultFilterFunc;
    return (_jsx(_Fragment, { children: _jsx(Table, { enableFullScreenToggle: false, enableFacetedValues: true, errorMessage: errorMessage, 
            // @todo: once KubeObject is not any we can remove this casting
            columns: allColumns, data: (data ?? []), loading: data === null, initialState: initialState, rowsPerPage: storeRowsPerPageOptions, state: {
                columnVisibility,
            }, reflectInURL: reflectInURL, onColumnVisibilityChange: onColumnsVisibilityChange, enableRowActions: enableRowActions, renderRowActionMenuItems: renderRowActionMenuItems, filterFns: {
                kubeObjectSearch: (row, id, filterValue) => {
                    const customFilterResult = filterFunc(row.original, filterValue);
                    const fuzzyColumnsResult = MRT_FilterFns.contains(row, id, filterValue);
                    return customFilterResult || fuzzyColumnsResult;
                },
            }, globalFilterFn: "kubeObjectSearch", filterFunction: filterFunc }) }));
}
