import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { InlineIcon } from '@iconify/react';
import Button from '@mui/material/Button';
import FormControl from '@mui/material/FormControl';
import InputLabel from '@mui/material/InputLabel';
import MenuItem from '@mui/material/MenuItem';
import Select from '@mui/material/Select';
import React from 'react';
import { useTranslation } from 'react-i18next';
import { useDispatch } from 'react-redux';
import { useLocation } from 'react-router-dom';
import { useClusterGroup } from '../../../lib/k8s';
import { apply } from '../../../lib/k8s/apiProxy';
import { clusterAction } from '../../../redux/clusterActionSlice';
import { EventStatus, HeadlampEventType, useEventCallback, } from '../../../redux/headlampEventSlice';
import ActionButton from '../ActionButton';
import EditorDialog from './EditorDialog';
export default function CreateButton(props) {
    const { isNarrow } = props;
    const dispatch = useDispatch();
    const [openDialog, setOpenDialog] = React.useState(false);
    const [errorMessage, setErrorMessage] = React.useState('');
    const location = useLocation();
    const { t } = useTranslation(['translation']);
    const dispatchCreateEvent = useEventCallback(HeadlampEventType.CREATE_RESOURCE);
    const clusters = useClusterGroup();
    const [targetCluster, setTargetCluster] = React.useState(clusters[0] || '');
    // When the clusters in the group change, we want to reset the target cluster
    // if it's not in the new list of clusters.
    React.useEffect(() => {
        if (clusters.length === 0) {
            setTargetCluster('');
        }
        else if (!clusters.includes(targetCluster)) {
            setTargetCluster(clusters[0]);
        }
    }, [clusters]);
    const applyFunc = async (newItems, clusterName) => {
        await Promise.allSettled(newItems.map(newItem => apply(newItem, clusterName))).then((values) => {
            values.forEach((value, index) => {
                if (value.status === 'rejected') {
                    let msg;
                    const kind = newItems[index].kind;
                    const name = newItems[index].metadata.name;
                    const apiVersion = newItems[index].apiVersion;
                    if (newItems.length === 1) {
                        msg = t('translation|Failed to create {{ kind }} {{ name }}.', { kind, name });
                    }
                    else {
                        msg = t('translation|Failed to create {{ kind }} {{ name }} in {{ apiVersion }}.', {
                            kind,
                            name,
                            apiVersion,
                        });
                    }
                    setErrorMessage(msg);
                    setOpenDialog(true);
                    throw msg;
                }
            });
        });
    };
    function handleSave(newItemDefs) {
        let massagedNewItemDefs = newItemDefs;
        const cancelUrl = location.pathname;
        // check if all yaml objects are valid
        for (let i = 0; i < massagedNewItemDefs.length; i++) {
            if (massagedNewItemDefs[i].kind === 'List') {
                // flatten this List kind with the items that it has which is a list of valid k8s resources
                const deletedItem = massagedNewItemDefs.splice(i, 1);
                massagedNewItemDefs = massagedNewItemDefs.concat(deletedItem[0].items);
            }
            if (!massagedNewItemDefs[i].metadata?.name) {
                setErrorMessage(t(`translation|Invalid: One or more of resources doesn't have a name property`));
                return;
            }
            if (!massagedNewItemDefs[i].kind) {
                setErrorMessage(t('translation|Invalid: Please set a kind to the resource'));
                return;
            }
        }
        // all resources name
        const resourceNames = massagedNewItemDefs.map(newItemDef => newItemDef.metadata.name);
        setOpenDialog(false);
        dispatch(clusterAction(() => applyFunc(massagedNewItemDefs, targetCluster), {
            startMessage: t('translation|Applying {{ newItemName }}â€¦', {
                newItemName: resourceNames.join(','),
            }),
            cancelledMessage: t('translation|Cancelled applying {{ newItemName }}.', {
                newItemName: resourceNames.join(','),
            }),
            successMessage: t('translation|Applied {{ newItemName }}.', {
                newItemName: resourceNames.join(','),
            }),
            errorMessage: t('translation|Failed to apply {{ newItemName }}.', {
                newItemName: resourceNames.join(','),
            }),
            cancelUrl,
        }));
        dispatchCreateEvent({
            status: EventStatus.CONFIRMED,
        });
    }
    return (_jsxs(React.Fragment, { children: [isNarrow ? (_jsx(ActionButton, { description: t('translation|Create / Apply'), onClick: () => setOpenDialog(true), icon: "mdi:plus-box", width: "48", iconButtonProps: {
                    color: 'primary',
                } })) : (_jsx(Button, { onClick: () => {
                    setOpenDialog(true);
                }, startIcon: _jsx(InlineIcon, { icon: "mdi:plus" }), color: "primary", variant: "contained", children: t('translation|Create') })), _jsx(EditorDialog, { item: {}, open: openDialog, onClose: () => setOpenDialog(false), onSave: handleSave, saveLabel: t('translation|Apply'), errorMessage: errorMessage, onEditorChanged: () => setErrorMessage(''), title: t('translation|Create / Apply'), actions: clusters.length > 1
                    ? [
                        _jsxs(FormControl, { children: [_jsx(InputLabel, { id: "edit-dialog-cluster-target", children: t('glossary|Cluster') }), _jsx(Select, { labelId: "edit-dialog-cluster-target", id: "edit-dialog-cluster-target-select", value: targetCluster, onChange: event => {
                                        setTargetCluster(event.target.value);
                                    }, children: clusters.map(cluster => (_jsx(MenuItem, { value: cluster, children: cluster }, cluster))) })] }),
                    ]
                    : [] })] }));
}
