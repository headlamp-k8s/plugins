import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import '../../../i18n/config';
import Editor, { loader } from '@monaco-editor/react';
import Box from '@mui/material/Box';
import Button from '@mui/material/Button';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import FormControlLabel from '@mui/material/FormControlLabel';
import FormGroup from '@mui/material/FormGroup';
import Grid from '@mui/material/Grid';
import Switch from '@mui/material/Switch';
import Typography from '@mui/material/Typography';
import * as yaml from 'js-yaml';
import * as monaco from 'monaco-editor/esm/vs/editor/editor.api';
import editorWorker from 'monaco-editor/esm/vs/editor/editor.worker?worker';
import cssWorker from 'monaco-editor/esm/vs/language/css/css.worker?worker';
import htmlWorker from 'monaco-editor/esm/vs/language/html/html.worker?worker';
import jsonWorker from 'monaco-editor/esm/vs/language/json/json.worker?worker';
import tsWorker from 'monaco-editor/esm/vs/language/typescript/ts.worker?worker';
import React from 'react';
import { useTranslation } from 'react-i18next';
import { getThemeName } from '../../../lib/themes';
import { useId } from '../../../lib/util';
import ConfirmButton from '../ConfirmButton';
import { Dialog } from '../Dialog';
import Loader from '../Loader';
import Tabs from '../Tabs';
import DocsViewer from './DocsViewer';
import SimpleEditor from './SimpleEditor';
self.MonacoEnvironment = {
    getWorker(_, label) {
        if (label === 'json') {
            return new jsonWorker();
        }
        if (label === 'css' || label === 'scss' || label === 'less') {
            return new cssWorker();
        }
        if (label === 'html' || label === 'handlebars' || label === 'razor') {
            return new htmlWorker();
        }
        if (label === 'typescript' || label === 'javascript') {
            return new tsWorker();
        }
        return new editorWorker();
    },
};
export default function EditorDialog(props) {
    const { item, onClose, onSave, onEditorChanged, saveLabel, errorMessage, title, actions = [], ...other } = props;
    const editorOptions = {
        selectOnLineNumbers: true,
        readOnly: isReadOnly(),
        automaticLayout: true,
    };
    const { i18n } = useTranslation();
    const [lang, setLang] = React.useState(i18n.language);
    const themeName = getThemeName();
    const originalCodeRef = React.useRef({ code: '', format: item ? 'yaml' : '' });
    const [code, setCode] = React.useState(originalCodeRef.current);
    const codeRef = React.useRef(code);
    const lastCodeCheckHandler = React.useRef(0);
    const previousVersionRef = React.useRef(item?.metadata?.resourceVersion || '');
    const [error, setError] = React.useState('');
    const [docSpecs, setDocSpecs] = React.useState([]);
    const { t } = useTranslation();
    const [useSimpleEditor, setUseSimpleEditorState] = React.useState(() => {
        const localData = localStorage.getItem('useSimpleEditor');
        return localData ? JSON.parse(localData) : false;
    });
    function setUseSimpleEditor(data) {
        localStorage.setItem('useSimpleEditor', JSON.stringify(data));
        setUseSimpleEditorState(data);
    }
    // Update the code when the item changes, but only if the code hasn't been touched.
    React.useEffect(() => {
        if (!item || Object.keys(item || {}).length === 0) {
            return;
        }
        const originalCode = originalCodeRef.current.code;
        const itemCode = originalCodeRef.current.format === 'json' ? JSON.stringify(item) : yaml.dump(item);
        if (itemCode !== originalCodeRef.current.code) {
            originalCodeRef.current = { code: itemCode, format: originalCodeRef.current.format };
        }
        if (!item.metadata) {
            return;
        }
        const resourceVersionsDiffer = (previousVersionRef.current || '') !== (item.metadata.resourceVersion || '');
        // Only change if the code hasn't been touched.
        // We use the codeRef in this effect instead of the code, because we need to access the current
        // state of the code but we don't want to trigger a re-render when we set the code here.
        if (resourceVersionsDiffer || codeRef.current.code === originalCode) {
            // Prevent updating to the same code, which would lead to an infinite loop.
            if (codeRef.current.code !== itemCode) {
                setCode({ code: itemCode, format: originalCodeRef.current.format });
            }
            if (resourceVersionsDiffer && !!item.metadata.resourceVersion) {
                previousVersionRef.current = item.metadata.resourceVersion;
            }
        }
    }, [item]);
    React.useEffect(() => {
        codeRef.current = code;
    }, [code]);
    React.useEffect(() => {
        i18n.on('languageChanged', setLang);
        return () => {
            // Stop the timeout from trying to use the component after it's been unmounted.
            clearTimeout(lastCodeCheckHandler.current);
            i18n.off('languageChanged', setLang);
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    function isReadOnly() {
        return onSave === null;
    }
    function looksLikeJson(code) {
        const trimmedCode = code.trimLeft();
        const firstChar = !!trimmedCode ? trimmedCode[0] : '';
        if (['{', '['].includes(firstChar)) {
            return true;
        }
        return false;
    }
    function onChange(value) {
        // Clear any ongoing attempts to check the code.
        window.clearTimeout(lastCodeCheckHandler.current);
        // Only check the code for errors after the user has stopped typing for a moment.
        lastCodeCheckHandler.current = window.setTimeout(() => {
            const { error: err, format } = getObjectsFromCode({
                code: value || '',
                format: originalCodeRef.current.format,
            });
            if (code.format !== format) {
                setCode(currentCode => ({ code: currentCode.code || '', format }));
            }
            if (error !== (err?.message || '')) {
                setError(err?.message || '');
            }
        }, 500); // ms
        setCode(currentCode => ({ code: value, format: currentCode.format }));
        if (onEditorChanged) {
            onEditorChanged(value);
        }
    }
    function getObjectsFromCode(codeInfo) {
        const { code, format } = codeInfo;
        const res = {
            obj: null,
            format,
            error: null,
        };
        if (!format || (!res.obj && looksLikeJson(code))) {
            res.format = 'json';
            try {
                let helperArr = [];
                const parsedCode = JSON.parse(code);
                if (!Array.isArray(parsedCode)) {
                    helperArr.push(parsedCode);
                }
                else {
                    helperArr = parsedCode;
                }
                res.obj = helperArr;
                return res;
            }
            catch (e) {
                res.error = new Error(e.message || t('Invalid JSON'));
            }
        }
        if (!res.obj) {
            res.format = 'yaml';
            try {
                res.obj = yaml.loadAll(code);
                return res;
            }
            catch (e) {
                res.error = new Error(e.message || t('Invalid YAML'));
            }
        }
        if (!!res.obj) {
            res.error = null;
        }
        return res;
    }
    function handleTabChange(tabIndex) {
        // Check if the docs tab has been selected.
        if (tabIndex !== 1) {
            return;
        }
        const { obj: codeObjs } = getObjectsFromCode(code);
        setDocSpecs(codeObjs);
    }
    function onUndo() {
        setCode(originalCodeRef.current);
    }
    function handleSave() {
        // Verify the YAML even means anything before trying to use it.
        const { obj, format, error } = getObjectsFromCode(code);
        if (!!error) {
            setError(t('Error parsing the code: {{error}}', { error: error.message }));
            return;
        }
        if (format !== code.format) {
            setCode(currentCode => ({ code: currentCode.code, format }));
        }
        if (!getObjectsFromCode(code)) {
            setError(t("Error parsing the code. Please verify it's valid YAML or JSON!"));
            return;
        }
        onSave(obj);
    }
    function makeEditor() {
        // @todo: monaco editor does not support pt, ta, hi amongst various other langs.
        if (['de', 'es', 'fr', 'it', 'ja', 'ko', 'ru', 'zh-cn', 'zh-tw'].includes(lang)) {
            loader.config({ 'vs/nls': { availableLanguages: { '*': lang } }, monaco });
        }
        else {
            loader.config({ monaco });
        }
        return useSimpleEditor ? (_jsx(Box, { paddingTop: 2, height: "100%", children: _jsx(SimpleEditor, { language: originalCodeRef.current.format || 'yaml', value: code.code, onChange: onChange }) })) : (_jsx(Box, { paddingTop: 2, height: "100%", children: _jsx(Editor, { language: originalCodeRef.current.format || 'yaml', theme: themeName === 'dark' ? 'vs-dark' : 'light', value: code.code, options: editorOptions, onChange: onChange, height: "600px" }) }));
    }
    const errorLabel = error || errorMessage;
    let dialogTitle = title;
    if (!dialogTitle && item) {
        const itemName = item.metadata?.name || t('New Object');
        dialogTitle = isReadOnly()
            ? t('translation|View: {{ itemName }}', { itemName })
            : t('translation|Edit: {{ itemName }}', { itemName });
    }
    const dialogTitleId = useId('editor-dialog-title-');
    return (_jsx(Dialog, { title: dialogTitle, "aria-busy": !item, maxWidth: "lg", scroll: "paper", fullWidth: true, withFullScreen: true, onClose: onClose, ...other, "aria-labelledby": dialogTitleId, titleProps: {
            id: dialogTitleId,
        }, children: !item ? (_jsx(Loader, { title: t('Loading editor') })) : (_jsxs(React.Fragment, { children: [_jsxs(DialogContent, { sx: {
                        height: '80%',
                        overflowY: 'hidden',
                    }, children: [_jsx(Box, { py: 1, children: _jsxs(Grid, { container: true, spacing: 2, justifyContent: "space-between", children: [actions.length > 0 ? (actions.map((action, i) => (_jsx(Grid, { item: true, children: action }, `editor_action_${i}`)))) : (_jsx(Grid, { item: true })) // Just to keep the layout consistent.
                                    , _jsx(Grid, { item: true, children: _jsx(FormGroup, { row: true, children: _jsx(FormControlLabel, { control: _jsx(Switch, { checked: useSimpleEditor, onChange: () => setUseSimpleEditor(!useSimpleEditor), name: "useSimpleEditor" }), label: t('Use minimal editor') }) }) })] }) }), isReadOnly() ? (makeEditor()) : (_jsx(Tabs, { onTabChanged: handleTabChange, ariaLabel: t('translation|Editor'), tabs: [
                                {
                                    label: t('translation|Editor'),
                                    component: makeEditor(),
                                },
                                {
                                    label: t('translation|Documentation'),
                                    component: (_jsx(Box, { p: 2, sx: {
                                            overflowY: 'auto',
                                            overflowX: 'hidden',
                                        }, maxHeight: 600, height: 600, children: _jsx(DocsViewer, { docSpecs: docSpecs }) })),
                                },
                            ] }))] }), _jsxs(DialogActions, { children: [!isReadOnly() && (_jsx(ConfirmButton, { disabled: originalCodeRef.current.code === code.code, color: "secondary", "aria-label": t('translation|Undo'), onConfirm: onUndo, confirmTitle: t('translation|Are you sure?'), confirmDescription: t('This will discard your changes in the editor. Do you want to proceed?'), children: t('translation|Undo Changes') })), _jsx("div", { style: { flex: '1 0 0' } }), errorLabel && _jsx(Typography, { color: "error", children: errorLabel }), _jsx("div", { style: { flex: '1 0 0' } }), _jsx(Button, { onClick: onClose, color: "primary", children: t('translation|Close') }), !isReadOnly() && (_jsx(Button, { onClick: handleSave, color: "primary", disabled: originalCodeRef.current.code === code.code || !!error, children: saveLabel || t('translation|Save & Apply') }))] })] })) }));
}
export function ViewDialog(props) {
    return _jsx(EditorDialog, { ...props, onSave: null });
}
