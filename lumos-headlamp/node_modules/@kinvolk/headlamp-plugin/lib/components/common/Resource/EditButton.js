import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from 'react';
import { useTranslation } from 'react-i18next';
import { useDispatch } from 'react-redux';
import { useLocation } from 'react-router-dom';
import { clusterAction } from '../../../redux/clusterActionSlice';
import { EventStatus, HeadlampEventType, useEventCallback, } from '../../../redux/headlampEventSlice';
import ActionButton from '../ActionButton';
import AuthVisible from './AuthVisible';
import EditorDialog from './EditorDialog';
import ViewButton from './ViewButton';
export default function EditButton(props) {
    const dispatch = useDispatch();
    const { item, options = {}, buttonStyle, afterConfirm } = props;
    const [openDialog, setOpenDialog] = React.useState(false);
    const [isReadOnly, setIsReadOnly] = React.useState(false);
    const [errorMessage, setErrorMessage] = React.useState('');
    const location = useLocation();
    const { t } = useTranslation(['translation', 'resource']);
    const dispatchHeadlampEditEvent = useEventCallback(HeadlampEventType.EDIT_RESOURCE);
    function makeErrorMessage(err) {
        const status = err.status;
        switch (status) {
            case 408:
                return 'Conflicts when trying to perform operation (code 408).';
            default:
                return `Failed to perform operation: code ${status}`;
        }
    }
    async function updateFunc(newItem) {
        try {
            await item.update(newItem);
        }
        catch (err) {
            setErrorMessage(makeErrorMessage(err));
            setOpenDialog(true);
            throw err;
        }
    }
    const applyFunc = React.useCallback(updateFunc, [item]);
    function handleSave(items) {
        const newItemDef = Array.isArray(items) ? items[0] : items;
        const cancelUrl = location.pathname;
        const itemName = item.metadata.name;
        setOpenDialog(false);
        dispatch(clusterAction(() => applyFunc(newItemDef), {
            startMessage: t('translation|Applying changes to {{ itemName }}â€¦', { itemName }),
            cancelledMessage: t('translation|Cancelled changes to {{ itemName }}.', { itemName }),
            successMessage: t('translation|Applied changes to {{ itemName }}.', { itemName }),
            errorMessage: t('translation|Failed to apply changes to {{ itemName }}.', { itemName }),
            cancelUrl,
            errorUrl: cancelUrl,
            ...options,
        }));
        dispatchHeadlampEditEvent({
            resource: item,
            status: EventStatus.CLOSED,
        });
        if (afterConfirm) {
            afterConfirm();
        }
    }
    if (!item) {
        return null;
    }
    if (isReadOnly) {
        return _jsx(ViewButton, { item: item });
    }
    return (_jsxs(AuthVisible, { item: item, authVerb: "update", onError: (err) => {
            console.error(`Error while getting authorization for edit button in ${item}:`, err);
            setIsReadOnly(true);
        }, onAuthResult: ({ allowed }) => {
            setIsReadOnly(!allowed);
        }, children: [_jsx(ActionButton, { description: t('translation|Edit'), buttonStyle: buttonStyle, onClick: () => {
                    setOpenDialog(true);
                    dispatchHeadlampEditEvent({
                        resource: item,
                        status: EventStatus.OPENED,
                    });
                }, icon: "mdi:pencil" }), openDialog && (_jsx(EditorDialog, { item: item.getEditableObject(), open: openDialog, onClose: () => setOpenDialog(false), onSave: handleSave, errorMessage: errorMessage, onEditorChanged: () => setErrorMessage('') }))] }));
}
