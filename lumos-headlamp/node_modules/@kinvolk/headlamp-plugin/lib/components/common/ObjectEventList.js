import { jsx as _jsx } from "react/jsx-runtime";
import { useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';
import Event from '../../lib/k8s/event';
import { localeDate, timeAgo } from '../../lib/util';
import { HeadlampEventType, useEventCallback } from '../../redux/headlampEventSlice';
import { HoverInfoLabel, SectionBox, SimpleTable } from '../common';
import ShowHideLabel from './ShowHideLabel';
export default function ObjectEventList(props) {
    const [events, setEvents] = useState([]);
    const dispatchEventList = useEventCallback(HeadlampEventType.OBJECT_EVENTS);
    useEffect(() => {
        if (events) {
            dispatchEventList(events, props.object);
        }
    }, [events]);
    async function fetchEvents() {
        try {
            const events = await Event.objectEvents(props.object);
            setEvents(events.map((e) => new Event(e)));
        }
        catch (e) {
            console.error('Failed to fetch events for object:', props.object, e);
        }
    }
    const { t } = useTranslation(['translation', 'glossary']);
    useEffect(() => {
        fetchEvents();
    }, []);
    return (_jsx(SectionBox, { title: t('glossary|Events'), children: _jsx(SimpleTable, { columns: [
                {
                    label: t('Type'),
                    getter: item => {
                        return item.type;
                    },
                },
                {
                    label: t('Reason'),
                    getter: item => {
                        return item.reason;
                    },
                },
                {
                    label: t('From'),
                    getter: item => {
                        return item.source.component;
                    },
                },
                {
                    label: t('Message'),
                    getter: item => {
                        return (item && (_jsx(ShowHideLabel, { labelId: item?.metadata?.uid || '', children: item.message || '' })));
                    },
                },
                {
                    label: t('Age'),
                    getter: item => {
                        if (item.count > 1) {
                            return `${timeAgo(item.lastOccurrence)} (${item.count} times over ${timeAgo(item.firstOccurrence)})`;
                        }
                        const eventDate = timeAgo(item.lastOccurrence, { format: 'mini' });
                        let label;
                        if (item.count > 1) {
                            label = t('{{ eventDate }} ({{ count }} times since {{ firstEventDate }})', {
                                eventDate,
                                count: item.count,
                                firstEventDate: timeAgo(item.firstOccurrence),
                            });
                        }
                        else {
                            label = eventDate;
                        }
                        return (_jsx(HoverInfoLabel, { label: label, hoverInfo: localeDate(item.lastOccurrence), icon: "mdi:calendar" }));
                    },
                    sort: (n1, n2) => new Date(n2.lastTimestamp).getTime() - new Date(n1.lastTimestamp).getTime(),
                },
            ], data: events }) }));
}
