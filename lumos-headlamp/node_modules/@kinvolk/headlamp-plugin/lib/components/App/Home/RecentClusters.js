import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import Grid from '@mui/material/Grid';
import React from 'react';
import { useTranslation } from 'react-i18next';
import { generatePath, useHistory } from 'react-router-dom';
import helpers from '../../../helpers';
import { createRouteURL } from '../../../lib/router';
import { getClusterPrefixedPath } from '../../../lib/util';
import SquareButton from './SquareButton';
function ClusterButton(props) {
    const { cluster, onClick = undefined, focusedRef } = props;
    return (_jsx(SquareButton, { focusRipple: true, icon: "mdi:kubernetes", label: cluster.name, ref: focusedRef, onClick: onClick }));
}
export default function RecentClusters(props) {
    const { clusters } = props;
    const history = useHistory();
    const focusedRef = React.useCallback((node) => {
        if (node !== null) {
            node.focus();
        }
    }, []);
    const { t } = useTranslation();
    const recentClustersLabelId = 'recent-clusters-label';
    const maxRecentClusters = 3;
    // We slice it here for the maximum recent clusters just for extra safety, since this
    // is an entry point to the rest of the functionality
    const recentClusterNames = helpers.getRecentClusters().slice(0, maxRecentClusters);
    let recentClusters = [];
    // If we have more than the maximum number of recent clusters allowed, we show the most
    // recent ones. Otherwise, just show the clusters in the order they are received.
    if (clusters.length > maxRecentClusters) {
        // Get clusters matching the recent cluster names, if they exist still.
        recentClusters = recentClusterNames
            .map(name => clusters.find(cluster => cluster.name === name))
            .filter(item => !!item);
        // See whether we need to fill with new clusters (when the recent clusters were less than the
        // maximum/wanted).
        const neededClusters = maxRecentClusters - recentClusters.length;
        if (neededClusters > 0) {
            recentClusters = recentClusters.concat(clusters.filter(item => !recentClusters.includes(item)).slice(0, neededClusters));
        }
    }
    else {
        recentClusters = clusters;
    }
    function onClusterButtonClicked(cluster) {
        helpers.setRecentCluster(cluster);
        history.push({
            pathname: generatePath(getClusterPrefixedPath(), {
                cluster: cluster.name,
            }),
        });
    }
    return (_jsxs(Grid, { "aria-labelledby": `#${recentClustersLabelId}`, item: true, container: true, alignItems: "flex-start", spacing: 2, children: [recentClusters.map((cluster, i) => (_jsx(Grid, { item: true, children: _jsx(ClusterButton, { focusedRef: i === 0 ? focusedRef : undefined, cluster: cluster, onClick: () => onClusterButtonClicked(cluster) }) }, cluster.name))), helpers.isElectron() && (_jsx(Grid, { item: true, children: _jsx(SquareButton, { onClick: () => {
                        history.push(createRouteURL('loadKubeConfig'));
                    }, label: t('Load cluster'), icon: "mdi:plus-circle-outline", primary: true }) }))] }));
}
