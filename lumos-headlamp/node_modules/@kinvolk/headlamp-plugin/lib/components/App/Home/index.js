import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Icon } from '@iconify/react';
import { useTheme } from '@mui/material';
import Box from '@mui/material/Box';
import IconButton from '@mui/material/IconButton';
import ListItemText from '@mui/material/ListItemText';
import Menu from '@mui/material/Menu';
import MenuItem from '@mui/material/MenuItem';
import Tooltip from '@mui/material/Tooltip';
import Typography from '@mui/material/Typography';
import { isEqual } from 'lodash';
import React from 'react';
import { useTranslation } from 'react-i18next';
import { useDispatch } from 'react-redux';
import { useHistory } from 'react-router-dom';
import helpers from '../../../helpers';
import { useClustersConf, useClustersVersion } from '../../../lib/k8s';
import { deleteCluster } from '../../../lib/k8s/apiProxy';
import Event from '../../../lib/k8s/event';
import { createRouteURL } from '../../../lib/router';
import { useId } from '../../../lib/util';
import { setConfig } from '../../../redux/configSlice';
import { Link, PageGrid, SectionBox, SectionFilterHeader } from '../../common';
import { ConfirmDialog } from '../../common';
import ResourceTable from '../../common/Resource/ResourceTable';
import RecentClusters from './RecentClusters';
function ContextMenu({ cluster }) {
    const { t } = useTranslation(['translation']);
    const history = useHistory();
    const dispatch = useDispatch();
    const [anchorEl, setAnchorEl] = React.useState(null);
    const menuId = useId('context-menu');
    const [openConfirmDialog, setOpenConfirmDialog] = React.useState(false);
    function removeCluster(cluster) {
        deleteCluster(cluster.name || '')
            .then(config => {
            dispatch(setConfig(config));
        })
            .catch((err) => {
            if (err.message === 'Not Found') {
                // TODO: create notification with error message
            }
        })
            .finally(() => {
            history.push('/');
        });
    }
    function handleMenuClose() {
        setAnchorEl(null);
    }
    return (_jsxs(_Fragment, { children: [_jsx(Tooltip, { title: t('Actions'), children: _jsx(IconButton, { size: "small", onClick: event => {
                        setAnchorEl(event.currentTarget);
                    }, "aria-haspopup": "menu", "aria-controls": menuId, "aria-label": t('Actions'), children: _jsx(Icon, { icon: "mdi:more-vert" }) }) }), _jsxs(Menu, { id: menuId, anchorEl: anchorEl, keepMounted: true, open: Boolean(anchorEl), onClose: () => {
                    handleMenuClose();
                }, children: [_jsx(MenuItem, { onClick: () => {
                            history.push(createRouteURL('cluster', { cluster: cluster.name }));
                            handleMenuClose();
                        }, children: _jsx(ListItemText, { children: t('translation|View') }) }), _jsx(MenuItem, { onClick: () => {
                            history.push(createRouteURL('settingsCluster', { cluster: cluster.name }));
                            handleMenuClose();
                        }, children: _jsx(ListItemText, { children: t('translation|Settings') }) }), helpers.isElectron() && cluster.meta_data?.source === 'dynamic_cluster' && (_jsx(MenuItem, { onClick: () => {
                            setOpenConfirmDialog(true);
                            handleMenuClose();
                        }, children: _jsx(ListItemText, { children: t('translation|Delete') }) }))] }), _jsx(ConfirmDialog, { open: openConfirmDialog, handleClose: () => setOpenConfirmDialog(false), onConfirm: () => {
                    setOpenConfirmDialog(false);
                    removeCluster(cluster);
                }, title: t('translation|Delete Cluster'), description: t('translation|Are you sure you want to remove the cluster "{{ clusterName }}"?', {
                    clusterName: cluster.name,
                }) })] }));
}
function ClusterStatus({ error }) {
    const { t } = useTranslation(['translation']);
    const theme = useTheme();
    const stateUnknown = error === undefined;
    const hasReachError = error && error.status !== 401 && error.status !== 403;
    return (_jsx(Box, { width: "fit-content", children: _jsxs(Box, { display: "flex", alignItems: "center", justifyContent: "center", children: [hasReachError ? (_jsx(Icon, { icon: "mdi:cloud-off", width: 16, color: theme.palette.home.status.error })) : stateUnknown ? (_jsx(Icon, { icon: "mdi:cloud-question", width: 16, color: theme.palette.home.status.unknown })) : (_jsx(Icon, { icon: "mdi:cloud-check-variant", width: 16, color: theme.palette.home.status.success })), _jsx(Typography, { variant: "body2", style: {
                        marginLeft: theme.spacing(1),
                        color: hasReachError
                            ? theme.palette.home.status.error
                            : !stateUnknown
                                ? theme.palette.home.status.success
                                : undefined,
                    }, children: hasReachError ? error.message : stateUnknown ? '⋯' : t('translation|Active') })] }) }));
}
export default function Home() {
    const history = useHistory();
    const clusters = useClustersConf() || {};
    if (!helpers.isElectron() && Object.keys(clusters).length === 1) {
        history.push(createRouteURL('cluster', { cluster: Object.keys(clusters)[0] }));
        return null;
    }
    return _jsx(HomeComponent, { clusters: clusters }, Object.keys(clusters).join(''));
}
function useWarningSettingsPerCluster(clusterNames) {
    const warningsMap = Event.useWarningList(clusterNames);
    const [warningLabels, setWarningLabels] = React.useState({});
    const maxWarnings = 50;
    function renderWarningsText(warnings, clusterName) {
        const numWarnings = (!!warnings[clusterName]?.error && -1) || (warnings[clusterName]?.warnings?.length ?? -1);
        if (numWarnings === -1) {
            return '⋯';
        }
        if (numWarnings >= maxWarnings) {
            return `${maxWarnings}+`;
        }
        return numWarnings.toString();
    }
    React.useEffect(() => {
        setWarningLabels(currentWarningLabels => {
            const newWarningLabels = {};
            for (const cluster of clusterNames) {
                newWarningLabels[cluster] = renderWarningsText(warningsMap, cluster);
            }
            if (!isEqual(newWarningLabels, currentWarningLabels)) {
                return newWarningLabels;
            }
            return currentWarningLabels;
        });
    }, [warningsMap]);
    return warningLabels;
}
function HomeComponent(props) {
    const { clusters } = props;
    const [customNameClusters, setCustomNameClusters] = React.useState(getClusterNames());
    const { t } = useTranslation(['translation', 'glossary']);
    const [versions, errors] = useClustersVersion(Object.values(clusters));
    const warningLabels = useWarningSettingsPerCluster(Object.values(customNameClusters).map(c => c.name));
    React.useEffect(() => {
        setCustomNameClusters(currentNames => {
            if (isEqual(currentNames, getClusterNames())) {
                return currentNames;
            }
            return getClusterNames();
        });
    }, [customNameClusters]);
    function getClusterNames() {
        return Object.values(clusters)
            .map(c => ({
            ...c,
            name: c.meta_data?.extensions?.headlamp_info?.customName || c.name,
        }))
            .sort();
    }
    /**
     * Gets the origin of a cluster.
     *
     * @param cluster
     * @returns A description of where the cluster is picked up from: dynamic, in-cluster, or from a kubeconfig file.
     */
    function getOrigin(cluster) {
        if (cluster.meta_data?.source === 'kubeconfig') {
            const kubeconfigPath = process.env.KUBECONFIG ?? '~/.kube/config';
            return t('translation|Kubeconfig') + ` (${kubeconfigPath})`;
        }
        else if (cluster.meta_data?.source === 'dynamic_cluster') {
            return t('translation|Dynamic cluster');
        }
        else if (cluster.meta_data?.source === 'in_cluster') {
            return t('translation|In-cluster');
        }
        return 'Unknown';
    }
    const memoizedComponent = React.useMemo(() => (_jsxs(PageGrid, { children: [_jsx(SectionBox, { headerProps: { headerStyle: 'main' }, title: t('Home'), children: _jsx(RecentClusters, { clusters: Object.values(customNameClusters), onButtonClick: () => { } }) }), _jsx(SectionBox, { title: _jsx(SectionFilterHeader, { title: t('All Clusters'), noNamespaceFilter: true, headerStyle: "subsection" }), children: _jsx(ResourceTable, { defaultSortingColumn: { id: 'name', desc: false }, columns: [
                        {
                            id: 'name',
                            label: t('Name'),
                            getValue: cluster => cluster.name,
                            render: ({ name }) => (_jsx(Link, { routeName: "cluster", params: { cluster: name }, children: name })),
                        },
                        {
                            label: t('Origin'),
                            getValue: cluster => getOrigin(cluster),
                            render: ({ name }) => (_jsx(Typography, { variant: "body2", children: getOrigin(clusters[name]) })),
                        },
                        {
                            label: t('Status'),
                            getValue: cluster => cluster.name,
                            render: ({ name }) => _jsx(ClusterStatus, { error: errors[name] }),
                        },
                        {
                            label: t('Warnings'),
                            getValue: ({ name }) => warningLabels[name],
                        },
                        {
                            label: t('glossary|Kubernetes Version'),
                            getValue: ({ name }) => versions[name]?.gitVersion || '⋯',
                        },
                        {
                            label: '',
                            getValue: () => '',
                            cellProps: {
                                align: 'right',
                            },
                            render: cluster => _jsx(ContextMenu, { cluster: cluster }),
                        },
                    ], data: Object.values(customNameClusters), id: "headlamp-home-clusters" }) })] })), [customNameClusters, errors, versions, warningLabels]);
    return memoizedComponent;
}
