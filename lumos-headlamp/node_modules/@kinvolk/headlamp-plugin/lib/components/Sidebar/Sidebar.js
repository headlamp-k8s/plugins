import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { InlineIcon } from '@iconify/react';
import { Button } from '@mui/material';
import Box from '@mui/material/Box';
import Drawer from '@mui/material/Drawer';
import Grid from '@mui/material/Grid';
import List from '@mui/material/List';
import useMediaQuery from '@mui/material/useMediaQuery';
import React from 'react';
import { useTranslation } from 'react-i18next';
import { useDispatch } from 'react-redux';
import { useHistory } from 'react-router-dom';
import helpers from '../../helpers';
import { useCluster } from '../../lib/k8s';
import { createRouteURL } from '../../lib/router';
import { useTypedSelector } from '../../redux/reducers/reducers';
import { ActionButton } from '../common';
import CreateButton from '../common/Resource/CreateButton';
import NavigationTabs from './NavigationTabs';
import prepareRoutes from './prepareRoutes';
import SidebarItem from './SidebarItem';
import { DefaultSidebars, setSidebarSelected, setWhetherSidebarOpen, } from './sidebarSlice';
import VersionButton from './VersionButton';
export const drawerWidth = 240;
export const mobileDrawerWidth = 320;
export const drawerWidthClosed = 64;
// exported for backwards compatibility for plugins
export { DefaultSidebars };
export function useSidebarInfo() {
    const isSidebarOpen = useTypedSelector(state => state.sidebar.isSidebarOpen);
    const isSidebarOpenUserSelected = useTypedSelector(state => state.sidebar.isSidebarOpenUserSelected);
    const isTemporary = useMediaQuery('(max-width:599px)');
    const isNarrowOnly = useMediaQuery('(max-width:960px) and (min-width:600px)');
    const temporarySideBarOpen = isSidebarOpen === true && isTemporary && isSidebarOpenUserSelected === true;
    // The large sidebar does not open in medium view (600-960px).
    const isOpen = (isSidebarOpen === true && !isNarrowOnly) || (isSidebarOpen === true && temporarySideBarOpen);
    return {
        isCollapsed: !temporarySideBarOpen && !isNarrowOnly,
        isOpen,
        isNarrow: !isSidebarOpen || isNarrowOnly,
        canExpand: !isNarrowOnly,
        isTemporary,
        isUserOpened: isSidebarOpenUserSelected,
        width: isOpen ? `${drawerWidth}px` : isTemporary ? '0px' : `${drawerWidthClosed}px`,
    };
}
function AddClusterButton() {
    const history = useHistory();
    const { t } = useTranslation(['translation']);
    const { isOpen } = useSidebarInfo();
    return (_jsx(Box, { pb: 2, children: isOpen ? (_jsx(Button, { onClick: () => history.push(createRouteURL('loadKubeConfig')), startIcon: _jsx(InlineIcon, { icon: "mdi:plus-box-outline" }), children: t('translation|Add Cluster') })) : (_jsx(ActionButton, { onClick: () => history.push(createRouteURL('loadKubeConfig')), icon: "mdi:plus-box-outline", description: t('translation|Add Cluster'), color: "#adadad", width: 38 })) }));
}
function SidebarToggleButton() {
    const dispatch = useDispatch();
    const { isOpen, isNarrow, canExpand, isTemporary } = useSidebarInfo();
    const { t } = useTranslation();
    const isNarrowOnly = isNarrow && !canExpand;
    if (isTemporary || isNarrowOnly) {
        return null;
    }
    return (_jsx(Box, { textAlign: isOpen ? 'right' : 'center', children: _jsx(ActionButton, { iconButtonProps: {
                size: 'small',
            }, onClick: () => {
                dispatch(setWhetherSidebarOpen(!isOpen));
            }, icon: isOpen ? 'mdi:chevron-left-box-outline' : 'mdi:chevron-right-box-outline', description: t('translation|Collapse Sidebar') }) }));
}
function DefaultLinkArea(props) {
    const { sidebarName, isOpen } = props;
    if (sidebarName === DefaultSidebars.HOME) {
        return (_jsxs(Box, { display: "flex", justifyContent: "space-between", alignItems: "center", flexDirection: isOpen ? 'row' : 'column', p: 1, children: [_jsx(Box, { children: helpers.isElectron() && _jsx(AddClusterButton, {}) }), _jsx(Box, { children: _jsx(SidebarToggleButton, {}) })] }));
    }
    return (_jsxs(Box, { textAlign: "center", children: [_jsx(CreateButton, { isNarrow: !isOpen }), _jsxs(Box, { display: "flex", justifyContent: "space-between", alignItems: "center", flexDirection: isOpen ? 'row' : 'column', p: 1, children: [_jsx(Box, { children: _jsx(VersionButton, {}) }), _jsx(Box, { children: _jsx(SidebarToggleButton, {}) })] })] }));
}
export default function Sidebar() {
    const { t, i18n } = useTranslation(['glossary', 'translation']);
    const sidebar = useTypedSelector(state => state.sidebar);
    const { isOpen, isUserOpened, isNarrow, canExpand, isTemporary: isTemporaryDrawer, } = useSidebarInfo();
    const isNarrowOnly = isNarrow && !canExpand;
    const arePluginsLoaded = useTypedSelector(state => state.plugins.loaded);
    const namespaces = useTypedSelector(state => state.filter.namespaces);
    const dispatch = useDispatch();
    const cluster = useCluster();
    const items = React.useMemo(() => {
        // If the sidebar is null, then it means it should not be visible.
        if (sidebar.selected.sidebar === null) {
            return [];
        }
        return prepareRoutes(t, sidebar.selected.sidebar || '');
    }, [
        cluster,
        sidebar.selected,
        sidebar.entries,
        sidebar.filters,
        i18n.language,
        arePluginsLoaded,
    ]);
    const search = namespaces.size !== 0 ? `?namespace=${[...namespaces].join('+')}` : '';
    if (sidebar.selected.sidebar === null || !sidebar?.isVisible) {
        return null;
    }
    return (_jsx(PureSidebar, { items: items, open: isOpen, openUserSelected: isUserOpened, isNarrowOnly: isNarrowOnly, isTemporaryDrawer: isTemporaryDrawer, selectedName: sidebar?.selected.item, search: search, onToggleOpen: () => {
            dispatch(setWhetherSidebarOpen(!sidebar.isSidebarOpen));
        }, linkArea: _jsx(DefaultLinkArea, { sidebarName: sidebar.selected.sidebar || '', isOpen: isOpen }) }));
}
export function PureSidebar({ open, openUserSelected, items, selectedName, isTemporaryDrawer = false, isNarrowOnly = false, onToggleOpen, search, linkArea, }) {
    const { t } = useTranslation();
    const temporarySideBarOpen = open === true && isTemporaryDrawer && openUserSelected === true;
    // The large sidebar does not open in medium view (600-960px).
    const largeSideBarOpen = (open === true && !isNarrowOnly) || (open === true && temporarySideBarOpen);
    /**
     * For closing the sidebar if temporaryDrawer on mobile.
     */
    const toggleDrawer = (event) => {
        if (event.type === 'keydown' &&
            (event.key === 'Tab' ||
                event.key === 'Shift')) {
            return;
        }
        onToggleOpen();
    };
    const contents = (_jsxs(_Fragment, { children: [_jsx(Box, { sx: theme => ({
                    ...theme.mixins.toolbar,
                }) }), _jsxs(Grid, { sx: {
                    height: '100%',
                }, container: true, direction: "column", justifyContent: "space-between", wrap: "nowrap", children: [_jsx(Grid, { item: true, children: _jsx(List, { onClick: isTemporaryDrawer ? toggleDrawer : undefined, onKeyDown: isTemporaryDrawer ? toggleDrawer : undefined, children: items.map(item => (_jsx(SidebarItem, { selectedName: selectedName, fullWidth: largeSideBarOpen, search: search, ...item }, item.name))) }) }), _jsx(Grid, { item: true, children: _jsx(Box, { textAlign: "center", p: 0, sx: theme => ({
                                '&, & *, & svg': {
                                    color: theme.palette.sidebarLink.color,
                                },
                                '& .MuiButton-root': {
                                    color: theme.palette.sidebarButtonInLinkArea.color,
                                    '&:hover': {
                                        background: theme.palette.sidebarButtonInLinkArea.hover.background,
                                    },
                                },
                                '& .MuiButton-containedPrimary': {
                                    background: theme.palette.sidebarButtonInLinkArea.primary.background,
                                    '&:hover': {
                                        background: theme.palette.sidebarButtonInLinkArea.hover.background,
                                    },
                                },
                            }), children: linkArea }) })] })] }));
    const conditionalProps = isTemporaryDrawer
        ? {
            open: temporarySideBarOpen,
            onClose: onToggleOpen,
        }
        : {};
    return (_jsx(Box, { component: "nav", "aria-label": t('translation|Navigation'), children: _jsx(Drawer, { variant: isTemporaryDrawer ? 'temporary' : 'permanent', sx: theme => {
                const drawer = {
                    width: drawerWidth,
                    flexShrink: 0,
                    background: theme.palette.sidebarBg,
                };
                const drawerOpen = {
                    width: drawerWidth,
                    transition: theme.transitions.create('width', {
                        easing: theme.transitions.easing.sharp,
                        duration: theme.transitions.duration.enteringScreen,
                    }),
                    background: theme.palette.sidebarBg,
                };
                const drawerClose = {
                    transition: theme.transitions.create('width', {
                        easing: theme.transitions.easing.sharp,
                        duration: theme.transitions.duration.leavingScreen,
                    }),
                    overflowX: 'hidden',
                    width: '56px',
                    [theme.breakpoints.down('xs')]: {
                        background: 'initial',
                    },
                    [theme.breakpoints.down('sm')]: {
                        width: theme.spacing(0),
                    },
                    [theme.breakpoints.up('sm')]: {
                        width: '72px',
                    },
                    background: theme.palette.sidebarBg,
                };
                if ((isTemporaryDrawer && temporarySideBarOpen) ||
                    (!isTemporaryDrawer && largeSideBarOpen)) {
                    return { ...drawer, ...drawerOpen, '& .MuiPaper-root': { ...drawerOpen } };
                }
                else {
                    return { ...drawer, ...drawerClose, '& .MuiPaper-root': { ...drawerClose } };
                }
            }, ...conditionalProps, children: contents }) }));
}
export function useSidebarItem(sidebarDesc) {
    let itemName = null;
    let sidebar = DefaultSidebars.IN_CLUSTER;
    if (typeof sidebarDesc === 'string') {
        itemName = sidebarDesc;
    }
    else if (sidebarDesc === null) {
        sidebar = null;
    }
    else if (!!sidebarDesc) {
        itemName = sidebarDesc.item;
        if (!!sidebarDesc.sidebar) {
            sidebar = sidebarDesc.sidebar || DefaultSidebars.IN_CLUSTER;
        }
    }
    const dispatch = useDispatch();
    React.useEffect(() => {
        dispatch(setSidebarSelected({ item: itemName, sidebar: sidebar }));
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [itemName]);
}
export { NavigationTabs };
