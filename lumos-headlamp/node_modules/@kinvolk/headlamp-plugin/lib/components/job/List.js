import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Icon } from '@iconify/react';
import { Box } from '@mui/material';
import { useTranslation } from 'react-i18next';
import Job from '../../lib/k8s/job';
import { formatDuration } from '../../lib/util';
import { LightTooltip, StatusLabel } from '../common';
import ResourceListView from '../common/Resource/ResourceListView';
export function makeJobStatusLabel(job) {
    if (!job?.status?.conditions) {
        return null;
    }
    const conditionOptions = {
        Failed: {
            status: 'error',
            icon: 'mdi:alert-outline',
        },
        Complete: {
            status: 'success',
            icon: 'mdi:check-bold',
        },
        Suspended: {
            status: '',
            icon: 'mdi:pause',
        },
    };
    const condition = job.status.conditions.find(({ status, type }) => type in conditionOptions && status === 'True');
    if (!condition) {
        return null;
    }
    const tooltip = '';
    const conditionInfo = conditionOptions[condition.type || 'Suspended'];
    return (_jsx(LightTooltip, { title: tooltip, interactive: true, children: _jsx(Box, { display: "inline", children: _jsxs(StatusLabel, { status: conditionInfo.status, children: [condition.type, _jsx(Icon, { "aria-label": "hidden", icon: conditionInfo.icon, width: "1.2rem", height: "1.2rem" })] }) }) }));
}
export default function JobsList() {
    const [jobs, error] = Job.useList();
    return _jsx(JobsListRenderer, { jobs: jobs, error: Job.getErrorMessage(error), reflectTableInURL: true });
}
export function JobsListRenderer(props) {
    const { jobs, error, hideColumns = [], reflectTableInURL = 'jobs', noNamespaceFilter } = props;
    const { t } = useTranslation(['glossary', 'translation']);
    function getCompletions(job) {
        return `${job.spec.completions}/${job.spec.parallelism}`;
    }
    function sortByCompletions(job1, job2) {
        const parallelismSorted = job1.spec.parallelism - job2.spec.parallelism;
        if (parallelismSorted === 0) {
            return job1.spec.completions - job2.spec.completions;
        }
        return parallelismSorted;
    }
    return (_jsx(ResourceListView, { title: t('Jobs'), headerProps: {
            noNamespaceFilter,
        }, hideColumns: hideColumns, errorMessage: error, columns: [
            'name',
            'namespace',
            'cluster',
            {
                id: 'completions',
                label: t('Completions'),
                getValue: job => getCompletions(job),
                sort: sortByCompletions,
            },
            {
                id: 'conditions',
                label: t('translation|Conditions'),
                getValue: job => job.status?.conditions?.find(({ status }) => status === 'True') ??
                    null,
                render: job => makeJobStatusLabel(job),
            },
            {
                id: 'duration',
                label: t('translation|Duration'),
                getValue: job => {
                    const startTime = job.status?.startTime;
                    const completionTime = job.status?.completionTime;
                    if (!!startTime && !!completionTime) {
                        const duration = new Date(completionTime).getTime() - new Date(startTime).getTime();
                        return formatDuration(duration, { format: 'mini' });
                    }
                    return '-';
                },
                gridTemplate: 0.6,
            },
            {
                id: 'containers',
                label: t('Containers'),
                getValue: job => job
                    .getContainers()
                    .map(c => c.name)
                    .join(''),
                render: job => {
                    const containerNames = job.getContainers().map((c) => c.name);
                    const containerTooltip = containerNames.join('\n');
                    const containerText = containerNames.join(', ');
                    return (_jsx(LightTooltip, { title: containerTooltip, interactive: true, children: containerText }));
                },
            },
            {
                id: 'images',
                label: t('Images'),
                getValue: job => job
                    .getContainers()
                    .map(c => c.image)
                    .join(''),
                render: job => {
                    const containerImages = job.getContainers().map((c) => c.image);
                    const containerTooltip = containerImages.join('\n');
                    const containerText = containerImages.join(', ');
                    return (_jsx(LightTooltip, { title: containerTooltip, interactive: true, children: containerText }));
                },
            },
            'age',
        ], data: jobs, reflectInURL: reflectTableInURL, id: "headlamp-jobs" }));
}
