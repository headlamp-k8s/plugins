import { ConfigState } from '../redux/configSlice';
/**
 * Store the kubeconfig for a stateless cluster in IndexedDB.
 * @param kubeconfig - The kubeconfig to store.
 * @returns promise that resolves when the kubeconfig is successfully added.
 * @throws Error if IndexedDB is not supported.
 * @throws Error if the kubeconfig is invalid.
 */
export declare function storeStatelessClusterKubeconfig(kubeconfig: string): Promise<void>;
/**
 * Gets stateless cluster kubeconfigs from IndexedDB.
 * @returns A promise that resolves with the kubeconfigs.
 * @throws Error if IndexedDB is not supported.
 * @throws Error if the kubeconfig is invalid.
 */
export declare function getStatelessClusterKubeConfigs(): Promise<string[]>;
/**
 * Finds a kubeconfig by cluster name.
 * @param clusterName
 * @returns A promise that resolves with the kubeconfig, or null if not found.
 * @throws Error if IndexedDB is not supported.
 * @throws Error if the kubeconfig is invalid.
 */
export declare function findKubeconfigByClusterName(clusterName: string): Promise<string | null>;
/**
 * In the backend we use a unique ID to identify a user. If there is no ID in localStorage
 * we generate a new one and store it in localStorage. We then combine it with the
 * cluster name and this headlamp-userId to create a unique ID for a cluster. If we don't
 * do it then if 2 different users have a cluster with the same name, then the
 * proxy will be overwritten.
 * @returns headlamp-userId from localStorage
 */
export declare function getUserIdFromLocalStorage(): string;
/**
 * Compares the cluster config from the backend and the redux store
 * @param clusters
 * @param clustersToConfig
 * @returns true if the present stored config is different from the fetched one.
 */
export declare function isEqualClusterConfigs(currentConfig: ConfigState['clusters'], newConfig: ConfigState['clusters']): boolean;
/**
 * Parses the cluster config from the backend and updates the redux store
 * if the present stored config is different from the fetched one.
 */
export declare function fetchStatelessClusterKubeConfigs(dispatch: any): Promise<void>;
/**
 * deleteClusterKubeconfig deletes the kubeconfig for a stateless cluster from indexedDB
 * @param clusterName - The name of the cluster
 * @returns A promise that resolves with the kubeconfig, or null if not found.
 */
export declare function deleteClusterKubeconfig(clusterName: string): Promise<string | null>;
/**
 * Update the kubeconfig context extensions in IndexedDB.
 * @param kubeconfig - The kubeconfig to store.
 * @param customName - The custom name for the context extension.
 * @param clusterName - The name of the cluster to update the kubeconfig context for.
 * @returns promise that resolves when the kubeconfig is successfully updated and stored.
 * @throws Error if IndexedDB is not supported.
 * @throws Error if the kubeconfig is invalid.
 */
export declare function updateStatelessClusterKubeconfig(kubeconfig: string, customName: string, clusterName: string): Promise<void>;
declare const exportFunctions: {
    storeStatelessClusterKubeconfig: typeof storeStatelessClusterKubeconfig;
    getStatelessClusterKubeConfigs: typeof getStatelessClusterKubeConfigs;
    findKubeconfigByClusterName: typeof findKubeconfigByClusterName;
    getUserIdFromLocalStorage: typeof getUserIdFromLocalStorage;
    isEqualClusterConfigs: typeof isEqualClusterConfigs;
    fetchStatelessClusterKubeConfigs: typeof fetchStatelessClusterKubeConfigs;
    deleteClusterKubeconfig: typeof deleteClusterKubeconfig;
    updateStatelessClusterKubeconfig: typeof updateStatelessClusterKubeconfig;
    processClusterComparison: typeof isEqualClusterConfigs;
};
export default exportFunctions;
