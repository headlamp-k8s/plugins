import { KubeRole } from './role';
declare const ClusterRole_base: {
    new (json: KubeRole, cluster?: string): {
        jsonData: KubeRole;
        _clusterName: string;
        cluster: string;
        readonly detailsRoute: string;
        readonly pluralName: string;
        readonly listRoute: string;
        readonly kind: any;
        getDetailsLink(): string;
        getListLink(): string;
        getName(): string;
        getNamespace(): string | undefined;
        getCreationTs(): string;
        getAge(): string;
        getValue(prop: string): any;
        readonly metadata: import("./KubeMetadata").KubeMetadata;
        readonly isNamespaced: boolean;
        getEditableObject(): {};
        _class(): import("./KubeObject").KubeObjectClass;
        delete(): any;
        update(data: import("./KubeObject").KubeObjectInterface): any;
        scale(numReplicas: number): Promise<any>;
        patch(body: import("json-patch").OpPatch[]): any;
        getAuthorization(verb: string, reqResourseAttrs?: import("./KubeObject").AuthRequestResourceAttrs): Promise<any>;
    };
    readOnlyFields: string[];
    readonly kind: string;
    readonly apiName: string;
    readonly apiVersion: string | string[];
    readonly isNamespaced: boolean;
    _internalApiEndpoint?: ReturnType<typeof import("./apiProxy").apiFactoryWithNamespace | typeof import("./apiProxy").apiFactory>;
    apiEndpoint: {
        [other: string]: any;
        scale?: ReturnType<(apiRoot: string, resource: string) => {
            get: (namespace: string, name: string, clusterName?: string) => Promise<any>;
            put: (body: {
                metadata: import("./KubeMetadata").KubeMetadata;
                spec: {
                    replicas: number;
                };
            }, clusterName?: string) => Promise<any>;
            patch: (body: {
                spec: {
                    replicas: number;
                };
            }, metadata: import("./KubeMetadata").KubeMetadata, clusterName?: string) => Promise<any>;
        }>;
    } | {
        list: (cb: import("./apiProxy").StreamResultsCb, errCb: import("./apiProxy").StreamErrCb, queryParams?: import("./apiProxy").QueryParameters, cluster?: string) => Promise<() => void>;
        get: (name: string, cb: import("./apiProxy").StreamResultsCb, errCb: import("./apiProxy").StreamErrCb, queryParams?: import("./apiProxy").QueryParameters, cluster?: string) => Promise<() => void>;
        post: (body: JSON | object | import("./KubeObject").KubeObjectInterface, queryParams?: import("./apiProxy").QueryParameters, cluster?: string) => Promise<any>;
        put: (body: import("./KubeObject").KubeObjectInterface, queryParams?: import("./apiProxy").QueryParameters, cluster?: string) => Promise<any>;
        patch: (body: import("json-patch").OpPatch[], name: string, queryParams?: import("./apiProxy").QueryParameters, cluster?: string) => Promise<any>;
        delete: (name: string, queryParams?: import("./apiProxy").QueryParameters, cluster?: string) => Promise<any>;
        isNamespaced: boolean;
        apiInfo: {
            group: string;
            version: string;
            resource: string;
        }[];
    };
    readonly className: string;
    readonly detailsRoute: string;
    readonly pluralName: string;
    readonly listRoute: string;
    apiList<K extends import("./KubeObject").KubeObject>(this: (new (...args: any) => K) & typeof import("./KubeObject").KubeObject, onList: (arg: K[]) => void, onError?: (err: import("./apiProxy").ApiError, cluster?: string) => void, opts?: import("./KubeObject").ApiListSingleNamespaceOptions): any;
    useApiList<K extends import("./KubeObject").KubeObject>(this: (new (...args: any) => K) & typeof import("./KubeObject").KubeObject, onList: (...arg: any[]) => any, onError?: (err: import("./apiProxy").ApiError, cluster?: string) => void, opts?: import("./KubeObject").ApiListOptions): void;
    useList<K extends import("./KubeObject").KubeObject>(this: (new (...args: any) => K) & typeof import("./KubeObject").KubeObject, { cluster, clusters, namespace, ...queryParams }?: {
        cluster?: string;
        clusters?: string[];
        namespace?: string | string[];
    } & import("./apiProxy").QueryParameters): [K[] | null, import("./apiProxy").ApiError | null] & import("./api/v2/hooks").QueryListResponse<(import("./api/v2/useKubeObjectList").ListResponse<K> | null | undefined)[], K, import("./apiProxy").ApiError>;
    useGet<K extends import("./KubeObject").KubeObject>(this: new (...args: any) => K, name: string, namespace?: string, opts?: {
        queryParams?: import("./apiProxy").QueryParameters;
        cluster?: string;
    }): [K | null, import("./apiProxy").ApiError | null] & import("./api/v2/hooks").QueryResponse<K, import("./apiProxy").ApiError>;
    create<Args extends any[], T extends import("./KubeObject").KubeObject>(this: new (...args: Args) => T, ...item: Args): T;
    apiGet<K extends import("./KubeObject").KubeObject>(this: (new (...args: any) => K) & typeof import("./KubeObject").KubeObject, onGet: (...args: any) => void, name: string, namespace?: string, onError?: (err: import("./apiProxy").ApiError | null, cluster?: string) => void, opts?: {
        queryParams?: import("./apiProxy").QueryParameters;
        cluster?: string;
    }): any;
    useApiGet<K extends import("./KubeObject").KubeObject>(this: (new (...args: any) => K) & typeof import("./KubeObject").KubeObject, onGet: (item: K | null) => any, name: string, namespace?: string, onError?: (err: import("./apiProxy").ApiError | null, cluster?: string) => void, opts?: {
        queryParams?: import("./apiProxy").QueryParameters;
        cluster?: string;
    }): void;
    put(data: import("./KubeObject").KubeObjectInterface): any;
    fetchAuthorization(reqResourseAttrs?: import("./KubeObject").AuthRequestResourceAttrs): Promise<any>;
    getAuthorization(verb: string, reqResourseAttrs?: import("./KubeObject").AuthRequestResourceAttrs): Promise<any>;
    getErrorMessage(err: import("./apiProxy").ApiError | null): "Error: Not found" | "Error: No permissions" | "Error" | null;
};
declare class ClusterRole extends ClusterRole_base {
    static kind: string;
    static apiName: string;
    static apiVersion: string;
    static isNamespaced: boolean;
    get rules(): {
        apiGroups: string[];
        nonResourceURLs: string[];
        resourceNames: string[];
        resources: string[];
        verbs: string[];
    }[];
}
export default ClusterRole;
