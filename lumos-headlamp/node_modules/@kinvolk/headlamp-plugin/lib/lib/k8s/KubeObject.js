import { JSONPath } from 'jsonpath-plus';
import { cloneDeep, unset } from 'lodash';
import React, { useMemo } from 'react';
import exportFunctions from '../../helpers';
import { getCluster } from '../cluster';
import { createRouteURL } from '../router';
import { timeAgo } from '../util';
import { useClusterGroup, useConnectApi } from '.';
import { useKubeObject } from './api/v2/hooks';
import { makeListRequests, useKubeObjectList } from './api/v2/useKubeObjectList';
import { apiFactory, apiFactoryWithNamespace, post } from './apiProxy';
function getAllowedNamespaces(cluster = getCluster()) {
    if (!cluster) {
        return [];
    }
    const clusterSettings = exportFunctions.loadClusterSettings(cluster);
    return clusterSettings.allowedNamespaces || [];
}
export class KubeObject {
    static get apiEndpoint() {
        if (this._internalApiEndpoint)
            return this._internalApiEndpoint;
        const factory = this.isNamespaced ? apiFactoryWithNamespace : apiFactory;
        const versions = Array.isArray(this.apiVersion) ? this.apiVersion : [this.apiVersion];
        // Create factory arguments per API version, usually just one
        const factoryArgumentsArray = versions.map(apiVersion => {
            const [group, version] = apiVersion.includes('/') ? apiVersion.split('/') : ['', apiVersion];
            const includeScaleApi = ['Deployment', 'ReplicaSet', 'StatefulSet'].includes(this.kind);
            return [group, version, this.apiName, includeScaleApi];
        });
        // Extract the first argument list if we only have one version
        // Because for resources with only one API version
        // the factory expects flat arguments instead of an array
        const factoryArguments = factoryArgumentsArray.length === 1
            ? factoryArgumentsArray[0]
            : factoryArgumentsArray;
        const endpoint = factory(...factoryArguments);
        this._internalApiEndpoint = endpoint;
        return endpoint;
    }
    static set apiEndpoint(endpoint) {
        this._internalApiEndpoint = endpoint;
    }
    constructor(json, cluster) {
        this.jsonData = json;
        this._clusterName = cluster || getCluster() || '';
    }
    get cluster() {
        return this._clusterName;
    }
    set cluster(cluster) {
        this._clusterName = cluster;
    }
    static get className() {
        return this.kind;
    }
    get detailsRoute() {
        return this._class().detailsRoute;
    }
    static get detailsRoute() {
        return this.kind;
    }
    static get pluralName() {
        // This is a naive way to get the plural name of the object by default. It will
        // work in most cases, but for exceptions (like Ingress), we must override this.
        return this.apiName;
    }
    get pluralName() {
        // In case we need to override the plural name in instances.
        return this._class().pluralName;
    }
    get listRoute() {
        return this._class().listRoute;
    }
    static get listRoute() {
        return this.apiName;
    }
    get kind() {
        return this.jsonData.kind;
    }
    getDetailsLink() {
        const params = {
            namespace: this.getNamespace(),
            name: this.getName(),
        };
        const link = createRouteURL(this.detailsRoute, params);
        return link;
    }
    getListLink() {
        return createRouteURL(this.listRoute);
    }
    getName() {
        return this.metadata.name;
    }
    getNamespace() {
        return this.metadata.namespace;
    }
    getCreationTs() {
        return this.metadata.creationTimestamp;
    }
    getAge() {
        return timeAgo(this.getCreationTs());
    }
    getValue(prop) {
        return this.jsonData[prop];
    }
    get metadata() {
        return this.jsonData.metadata;
    }
    get isNamespaced() {
        return this._class().isNamespaced;
    }
    getEditableObject() {
        const fieldsToRemove = this._class().readOnlyFields;
        const code = this.jsonData ? cloneDeep(this.jsonData) : {};
        fieldsToRemove?.forEach(path => {
            JSONPath({
                path,
                json: code,
                callback: (result, type, fullPayload) => {
                    if (fullPayload.parent && fullPayload.parentProperty) {
                        delete fullPayload.parent[fullPayload.parentProperty];
                    }
                },
                resultType: 'all',
            });
        });
        return code;
    }
    // @todo: apiList has 'any' return type.
    /**
     * Returns the API endpoint for this object.
     *
     * @param onList - Callback function to be called when the list is retrieved.
     * @param onError - Callback function to be called when an error occurs.
     * @param opts - Options to be passed to the API endpoint.
     *
     * @returns The API endpoint for this object.
     */
    static apiList(onList, onError, opts) {
        const createInstance = (item) => this.create(item);
        const args = [(list) => onList(list.map((item) => createInstance(item)))];
        if (this.apiEndpoint.isNamespaced) {
            args.unshift(opts?.namespace || null);
        }
        args.push(onError);
        const queryParams = {};
        if (opts?.queryParams?.labelSelector) {
            queryParams['labelSelector'] = opts.queryParams.labelSelector;
        }
        if (opts?.queryParams?.fieldSelector) {
            queryParams['fieldSelector'] = opts.queryParams.fieldSelector;
        }
        if (opts?.queryParams?.limit) {
            queryParams['limit'] = opts.queryParams.limit;
        }
        args.push(queryParams);
        args.push(opts?.cluster);
        return this.apiEndpoint.list.bind(null, ...args);
    }
    static useApiList(onList, onError, opts) {
        const [objs, setObjs] = React.useState({});
        const listCallback = onList;
        function onObjs(namespace, objList) {
            let newObjs = {};
            // Set the objects so we have them for the next API response...
            setObjs(previousObjs => {
                newObjs = { ...previousObjs, [namespace || '']: objList };
                return newObjs;
            });
            let allObjs = [];
            Object.values(newObjs).map(currentObjs => {
                allObjs = allObjs.concat(currentObjs);
            });
            listCallback(allObjs);
        }
        const listCalls = [];
        const queryParams = cloneDeep(opts);
        let namespaces = [];
        unset(queryParams, 'namespace');
        const cluster = opts?.cluster;
        if (!!opts?.namespace) {
            if (typeof opts.namespace === 'string') {
                namespaces = [opts.namespace];
            }
            else if (Array.isArray(opts.namespace)) {
                namespaces = opts.namespace;
            }
            else {
                throw Error('namespace should be a string or array of strings');
            }
        }
        // If the request itself has no namespaces set, we check whether to apply the
        // allowed namespaces.
        if (namespaces.length === 0 && this.isNamespaced) {
            namespaces = getAllowedNamespaces();
        }
        if (namespaces.length > 0) {
            // If we have a namespace set, then we have to make an API call for each
            // namespace and then set the objects once we have all of the responses.
            for (const namespace of namespaces) {
                listCalls.push(this.apiList(objList => onObjs(namespace, objList), onError, {
                    namespace,
                    queryParams,
                    cluster,
                }));
            }
        }
        else {
            // If we don't have a namespace set, then we only have one API call
            // response to set and we return it right away.
            listCalls.push(this.apiList(listCallback, onError, { queryParams, cluster }));
        }
        useConnectApi(...listCalls);
    }
    static useList({ cluster, clusters, namespace, ...queryParams } = {}) {
        const fallbackClusters = useClusterGroup();
        // Create requests for each cluster and namespace
        const requests = useMemo(() => {
            const clusterList = cluster
                ? [cluster]
                : clusters || (fallbackClusters.length === 0 ? [''] : fallbackClusters);
            const namespacesFromParams = typeof namespace === 'string'
                ? [namespace]
                : Array.isArray(namespace)
                    ? namespace
                    : undefined;
            return makeListRequests(clusterList, getAllowedNamespaces, this.isNamespaced, namespacesFromParams);
        }, [cluster, clusters, fallbackClusters, namespace, this.isNamespaced]);
        const result = useKubeObjectList({
            queryParams: queryParams,
            kubeObjectClass: this,
            requests,
        });
        return result;
    }
    static useGet(name, namespace, opts) {
        return useKubeObject({
            kubeObjectClass: this,
            name: name,
            namespace: namespace,
            cluster: opts?.cluster,
            queryParams: opts?.queryParams,
        });
    }
    static create(...item) {
        return new this(...item);
    }
    static apiGet(onGet, name, namespace, onError, opts) {
        const createInstance = (item) => this.create(item);
        const args = [name, (obj) => onGet(createInstance(obj))];
        if (this.apiEndpoint.isNamespaced) {
            args.unshift(namespace);
        }
        args.push(onError);
        args.push(opts?.queryParams);
        args.push(opts?.cluster);
        return this.apiEndpoint.get.bind(null, ...args);
    }
    static useApiGet(onGet, name, namespace, onError, opts) {
        // We do the type conversion here because we want to be able to use hooks that may not have
        // the exact signature as get callbacks.
        const getCallback = onGet;
        useConnectApi(this.apiGet(getCallback, name, namespace, onError, opts));
    }
    _class() {
        return this.constructor;
    }
    delete() {
        const args = [this.getName()];
        if (this.isNamespaced) {
            args.unshift(this.getNamespace());
        }
        // @ts-ignore
        return this._class().apiEndpoint.delete(...args, {}, this._clusterName);
    }
    update(data) {
        return this._class().apiEndpoint.put(data, {}, this._clusterName);
    }
    static put(data) {
        return this.apiEndpoint.put(data);
    }
    scale(numReplicas) {
        const hasScaleApi = Object.keys(this._class().apiEndpoint).includes('scale');
        if (!hasScaleApi) {
            throw new Error(`This class has no scale API: ${this._class().className}`);
        }
        const spec = {
            replicas: numReplicas,
        };
        return this._class().apiEndpoint.scale.patch({
            spec,
        }, this.metadata, this._clusterName);
    }
    patch(body) {
        const args = [body];
        if (this.isNamespaced) {
            args.push(this.getNamespace());
        }
        args.push(this.getName());
        // @ts-ignore
        return this._class().apiEndpoint.patch(...args, {}, this._clusterName);
    }
    /** Performs a request to check if the user has the given permission.
     * @param reResourceAttrs The attributes describing this access request. See https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/self-subject-access-review-v1/#SelfSubjectAccessReviewSpec .
     * @returns The result of the access request.
     */
    static async fetchAuthorization(reqResourseAttrs) {
        // @todo: We should get the API info from the API endpoint.
        const authApiVersions = ['v1', 'v1beta1'];
        for (let j = 0; j < authApiVersions.length; j++) {
            const authVersion = authApiVersions[j];
            try {
                return await post(`/apis/authorization.k8s.io/${authVersion}/selfsubjectaccessreviews`, {
                    kind: 'SelfSubjectAccessReview',
                    apiVersion: `authorization.k8s.io/${authVersion}`,
                    spec: {
                        resourceAttributes: reqResourseAttrs,
                    },
                }, false);
            }
            catch (err) {
                // If this is the last attempt or the error is not 404, let it throw.
                if (err.status !== 404 || j === authApiVersions.length - 1) {
                    throw err;
                }
            }
        }
    }
    static async getAuthorization(verb, reqResourseAttrs) {
        const resourceAttrs = {
            verb,
            ...reqResourseAttrs,
        };
        if (!resourceAttrs.resource) {
            resourceAttrs['resource'] = this.pluralName;
        }
        // @todo: We should get the API info from the API endpoint.
        // If we already have the group, version, and resource, then we can make the request
        // without trying the API info, which may have several versions and thus be less optimal.
        if (!!resourceAttrs.group && !!resourceAttrs.version && !!resourceAttrs.resource) {
            return this.fetchAuthorization(resourceAttrs);
        }
        // If we don't have the group, version, and resource, then we have to try all of the
        // API info versions until we find one that works.
        const apiInfo = this.apiEndpoint.apiInfo;
        for (let i = 0; i < apiInfo.length; i++) {
            const { group, version, resource } = apiInfo[i];
            // We only take from the details from the apiInfo if they're missing from the resourceAttrs.
            // The idea is that, since this function may also be called from the instance's getAuthorization,
            // it may already have the details from the instance's API version.
            const attrs = { ...resourceAttrs };
            if (!!attrs.resource) {
                attrs.resource = resource;
            }
            if (!!attrs.group) {
                attrs.group = group;
            }
            if (!!attrs.version) {
                attrs.version = version;
            }
            let authResult;
            try {
                authResult = await this.fetchAuthorization(attrs);
            }
            catch (err) {
                // If this is the last attempt or the error is not 404, let it throw.
                if (err.status !== 404 || i === apiInfo.length - 1) {
                    throw err;
                }
            }
            if (!!authResult) {
                return authResult;
            }
        }
    }
    async getAuthorization(verb, reqResourseAttrs) {
        const resourceAttrs = {
            name: this.getName(),
            verb,
            ...reqResourseAttrs,
        };
        const namespace = this.getNamespace();
        if (!resourceAttrs.namespace && !!namespace) {
            resourceAttrs['namespace'] = namespace;
        }
        // Set up the group and version from the object's API version.
        let [group, version] = this.jsonData?.apiVersion?.split('/') ?? [];
        if (!version) {
            version = group;
            group = '';
        }
        if (!!group) {
            resourceAttrs['group'] = group;
        }
        if (!!version) {
            resourceAttrs['version'] = version;
        }
        return this._class().getAuthorization(verb, resourceAttrs);
    }
    static getErrorMessage(err) {
        if (!err) {
            return null;
        }
        switch (err.status) {
            case 404:
                return 'Error: Not found';
            case 403:
                return 'Error: No permissions';
            default:
                return 'Error';
        }
    }
}
/** Readonly field defined as JSONPath paths */
KubeObject.readOnlyFields = [];
/**
 * @deprecated This function is no longer recommended, it's kept for backwards compatibility.
 * Please extend KubeObject instead
 *
 * @returns A KubeObject implementation for the given object name.
 *
 * @param objectName The name of the object to create a KubeObject implementation for.
 */
export function makeKubeObject() {
    class KubeObjectInternal extends KubeObject {
    }
    return KubeObjectInternal;
}
