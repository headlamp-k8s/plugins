import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useMemo } from 'react';
import { getCluster } from '../../../cluster';
import { clusterFetch } from './fetch';
import { KubeObjectEndpoint } from './KubeObjectEndpoint';
import { makeUrl } from './makeUrl';
import { useWebSocket } from './webSocket';
/**
 * Returns a single KubeObject.
 */
export function useKubeObject({ kubeObjectClass, namespace, name, cluster: maybeCluster, queryParams, }) {
    const cluster = maybeCluster ?? getCluster() ?? '';
    const endpoint = useEndpoints(kubeObjectClass.apiEndpoint.apiInfo, cluster);
    const cleanedUpQueryParams = Object.fromEntries(Object.entries(queryParams ?? {}).filter(([, value]) => value !== undefined && value !== ''));
    const queryKey = useMemo(() => ['object', cluster, endpoint, namespace ?? '', name, cleanedUpQueryParams], [endpoint, namespace, name]);
    const client = useQueryClient();
    const query = useQuery({
        enabled: !!endpoint,
        placeholderData: null,
        staleTime: 5000,
        queryKey,
        queryFn: async () => {
            const url = makeUrl([KubeObjectEndpoint.toUrl(endpoint, namespace), name], cleanedUpQueryParams);
            const obj = await clusterFetch(url, {
                cluster,
            }).then(it => it.json());
            return new kubeObjectClass(obj);
        },
    });
    const data = query.error ? null : query.data ?? null;
    useWebSocket({
        url: () => makeUrl([KubeObjectEndpoint.toUrl(endpoint)], {
            ...cleanedUpQueryParams,
            watch: 1,
            fieldSelector: `metadata.name=${name}`,
        }),
        enabled: !!endpoint && !!data,
        cluster,
        onMessage(update) {
            if (update.type !== 'ADDED' && update.object) {
                client.setQueryData(queryKey, new kubeObjectClass(update.object));
            }
        },
    });
    // @ts-ignore
    return {
        data,
        error: query.error,
        isError: query.isError,
        isLoading: query.isLoading,
        isFetching: query.isFetching,
        isSuccess: query.isSuccess,
        status: query.status,
        *[Symbol.iterator]() {
            yield data;
            yield query.error;
        },
    };
}
/**
 * Test different endpoints to see which one is working.
 *
 * @params endpoints - List of possible endpoints
 * @returns Endpoint that works
 *
 * @throws Error
 * When no endpoints are working
 */
const getWorkingEndpoint = async (endpoints, cluster, namespace) => {
    const promises = endpoints.map(endpoint => {
        return clusterFetch(KubeObjectEndpoint.toUrl(endpoint, namespace), {
            method: 'GET',
            cluster: cluster ?? getCluster() ?? '',
        }).then(it => {
            if (!it.ok) {
                throw new Error('error');
            }
            return endpoint;
        });
    });
    return Promise.any(promises);
};
/**
 * Checks and returns an endpoint that works from the list
 *
 * @params endpoints - List of possible endpoints
 */
export const useEndpoints = (endpoints, cluster, namespace) => {
    const { data: endpoint } = useQuery({
        enabled: endpoints.length > 1 && cluster !== undefined,
        queryKey: ['endpoints', endpoints],
        queryFn: () => getWorkingEndpoint(endpoints, cluster, namespace)
            .then(endpoints => endpoints)
            .catch(() => null),
    });
    if (cluster === null || cluster === undefined)
        return undefined;
    if (endpoints.length === 1)
        return endpoints[0];
    return endpoint;
};
