import { isDebugVerbose } from '../../../../helpers';
import { findKubeconfigByClusterName, getUserIdFromLocalStorage } from '../../../../stateless';
import { getToken } from '../../../auth';
import { getCluster } from '../../../cluster';
import { clusterRequest } from './clusterRequests';
import { BASE_HTTP_URL, CLUSTERS_PREFIX } from './constants';
import { asQuery, combinePath } from './formatUrl';
const BASE_WS_URL = BASE_HTTP_URL.replace('http', 'ws');
/**
 * Fetches the data and watches for changes to the data.
 *
 * @param url - The URL of the Kubernetes API endpoint.
 * @param name - The name of the Kubernetes API resource.
 * @param cb - The callback function to execute when the stream receives data.
 * @param errCb - The callback function to execute when an error occurs.
 * @param queryParams - The query parameters to include in the API request.
 *
 * @returns A function to cancel the stream.
 */
export function streamResult(url, name, cb, errCb, queryParams, cluster) {
    let isCancelled = false;
    let socket;
    const clusterName = cluster || getCluster() || '';
    if (isDebugVerbose('k8s/apiProxy@streamResult')) {
        console.debug('k8s/apiProxy@streamResult', { url, name, queryParams });
    }
    run();
    return Promise.resolve(cancel);
    async function run() {
        try {
            const item = await clusterRequest(`${url}/${name}` + asQuery(queryParams), {
                cluster: clusterName,
            });
            if (isCancelled)
                return;
            if (isDebugVerbose('k8s/apiProxy@streamResult run cb(item)')) {
                console.debug('k8s/apiProxy@streamResult run cb(item)', { item });
            }
            cb(item);
            const watchUrl = url +
                asQuery({ ...queryParams, ...{ watch: '1', fieldSelector: `metadata.name=${name}` } });
            socket = stream(watchUrl, (x) => cb(x.object), { isJson: true, cluster: clusterName });
        }
        catch (err) {
            console.error('Error in api request', { err, url });
            // @todo: sometimes errCb is {}, the typing for apiProxy needs improving.
            //        See https://github.com/kinvolk/headlamp/pull/833
            if (errCb && typeof errCb === 'function')
                errCb(err, cancel);
        }
    }
    function cancel() {
        if (isCancelled)
            return;
        isCancelled = true;
        if (socket)
            socket.cancel();
    }
}
/**
 * Streams the results of a Kubernetes API request.
 *
 * @param url - The URL of the Kubernetes API endpoint.
 * @param cb - The callback function to execute when the stream receives data.
 * @param errCb - The callback function to execute when an error occurs.
 * @param queryParams - The query parameters to include in the API request.
 *
 * @returns A function to cancel the stream.
 */
export function streamResults(url, cb, errCb, queryParams) {
    const cluster = getCluster() || '';
    return streamResultsForCluster(url, { cb, errCb, cluster }, queryParams);
}
// @todo: needs documenting
export function streamResultsForCluster(url, params, queryParams) {
    const { cb, errCb, cluster = '' } = params;
    const clusterName = cluster || getCluster() || '';
    const results = {};
    let isCancelled = false;
    let socket;
    if (isDebugVerbose('k8s/apiProxy@streamResults')) {
        console.debug('k8s/apiProxy@streamResults', { url, queryParams });
    }
    // -1 means unlimited.
    const maxResources = typeof queryParams?.limit === 'number'
        ? queryParams.limit
        : parseInt(queryParams?.limit ?? '-1');
    run();
    return Promise.resolve(cancel);
    async function run() {
        try {
            const { kind, items, metadata } = await clusterRequest(url + asQuery(queryParams), {
                cluster: clusterName,
            });
            if (isCancelled)
                return;
            add(items, kind);
            const watchUrl = url +
                asQuery({ ...queryParams, ...{ watch: '1', resourceVersion: metadata.resourceVersion } });
            socket = stream(watchUrl, update, { isJson: true, cluster: clusterName });
        }
        catch (err) {
            console.error('Error in api request', { err, url });
            if (errCb && typeof errCb === 'function') {
                errCb(err, cancel);
            }
        }
    }
    function cancel() {
        if (isCancelled)
            return;
        isCancelled = true;
        if (socket)
            socket.cancel();
    }
    function add(items, kind) {
        const fixedKind = kind.slice(0, -4); // Trim off the word "List" from the end of the string
        for (const item of items) {
            item.kind = fixedKind;
            results[item.metadata.uid] = item;
        }
        push();
    }
    function update({ type, object }) {
        object.actionType = type; // eslint-disable-line no-param-reassign
        switch (type) {
            case 'ADDED':
                results[object.metadata.uid] = object;
                break;
            case 'MODIFIED': {
                const existing = results[object.metadata.uid];
                if (existing) {
                    if (!existing.metadata.resourceVersion || !object.metadata.resourceVersion) {
                        console.error('Missing resourceVersion in object', object);
                        break;
                    }
                    const currentVersion = parseInt(existing.metadata.resourceVersion, 10);
                    const newVersion = parseInt(object.metadata.resourceVersion, 10);
                    if (currentVersion < newVersion) {
                        Object.assign(existing, object);
                    }
                }
                else {
                    results[object.metadata.uid] = object;
                }
                break;
            }
            case 'DELETED':
                delete results[object.metadata.uid];
                break;
            case 'ERROR':
                console.error('Error in update', { type, object });
                break;
            default:
                console.error('Unknown update type', type);
        }
        push();
    }
    function push() {
        const values = Object.values(results);
        // Limit the number of resources to maxResources. We do this because when we're streaming, the
        // API server will send us all the resources that match the query, without limitting, even if the
        // API params wanted to limit it. So we do the limitting here.
        if (maxResources > 0 && values.length > maxResources) {
            values.sort((a, b) => {
                const aTime = new Date(a.lastTimestamp || a.metadata.creationTimestamp).getTime();
                const bTime = new Date(b.lastTimestamp || b.metadata.creationTimestamp).getTime();
                // Reverse sort, so we have the most recent resources at the beginning of the array.
                return 0 - (aTime - bTime);
            });
            values.splice(0, values.length - maxResources);
        }
        if (isDebugVerbose('k8s/apiProxy@push cb(values)')) {
            console.debug('k8s/apiProxy@push cb(values)', { values });
        }
        cb(values);
    }
}
/**
 * Establishes a WebSocket connection to the specified URL and streams the results
 * to the provided callback function.
 *
 * @param url - The URL to connect to.
 * @param cb - The callback function to receive the streamed results.
 * @param args - Additional arguments to configure the stream.
 *
 * @returns An object with two functions: `cancel`, which can be called to cancel
 * the stream, and `getSocket`, which returns the WebSocket object.
 */
export function stream(url, cb, args) {
    let connection = null;
    let isCancelled = false;
    const { failCb, cluster = '' } = args;
    // We only set reconnectOnFailure as true by default if the failCb has not been provided.
    const { isJson = false, additionalProtocols, connectCb, reconnectOnFailure = !failCb } = args;
    if (isDebugVerbose('k8s/apiProxy@stream')) {
        console.debug('k8s/apiProxy@stream', { url, args });
    }
    connect();
    return { cancel, getSocket };
    function getSocket() {
        return connection ? connection.socket : null;
    }
    function cancel() {
        if (connection)
            connection.close();
        isCancelled = true;
    }
    async function connect() {
        if (connectCb)
            connectCb();
        try {
            connection = await connectStream(url, cb, onFail, isJson, additionalProtocols, cluster);
        }
        catch (error) {
            console.error('Error connecting stream:', error);
            onFail();
        }
    }
    function retryOnFail() {
        if (isCancelled)
            return;
        if (reconnectOnFailure) {
            if (isDebugVerbose('k8s/apiProxy@stream retryOnFail')) {
                console.debug('k8s/apiProxy@stream retryOnFail', 'Reconnecting in 3 seconds', { url });
            }
            setTimeout(connect, 3000);
        }
    }
    function onFail() {
        if (!!failCb) {
            failCb();
        }
        if (reconnectOnFailure) {
            retryOnFail();
        }
    }
}
// @todo: needs a return type.
/**
 * Connects to a WebSocket stream at the specified path and returns an object
 * with a `close` function and a `socket` property. Sends messages to `cb` callback.
 *
 * @param path - The path of the WebSocket stream to connect to.
 * @param cb - The function to call with each message received from the stream.
 * @param onFail - The function to call if the stream is closed unexpectedly.
 * @param isJson - Whether the messages should be parsed as JSON.
 * @param additionalProtocols - An optional array of additional WebSocket protocols to use.
 *
 * @returns An object with a `close` function and a `socket` property.
 */
export async function connectStream(path, cb, onFail, isJson, additionalProtocols = [], cluster = '') {
    return connectStreamWithParams(path, cb, onFail, {
        isJson,
        cluster: cluster || getCluster() || '',
        additionalProtocols,
    });
}
/**
 * connectStreamWithParams is a wrapper around connectStream that allows for more
 * flexibility in the parameters that can be passed to the WebSocket connection.
 *
 * This is an async function because it may need to fetch the kubeconfig for the
 * cluster if the cluster is specified in the params. If kubeconfig is found, it
 * sends the X-HEADLAMP-USER-ID header with the user ID from the localStorage.
 * It is sent as a base64url encoded string in protocal format:
 * `base64url.headlamp.authorization.k8s.io.${userID}`.
 *
 * @param path - The path of the WebSocket stream to connect to.
 * @param cb - The function to call with each message received from the stream.
 * @param onFail - The function to call if the stream is closed unexpectedly.
 * @param params - Stream parameters to configure the connection.
 *
 * @returns A promise that resolves to an object with a `close` function and a `socket` property.
 */
export async function connectStreamWithParams(path, cb, onFail, params) {
    const { isJson = false, additionalProtocols = [], cluster = '' } = params || {};
    let isClosing = false;
    const token = getToken(cluster || '');
    const userID = getUserIdFromLocalStorage();
    const protocols = ['base64.binary.k8s.io', ...additionalProtocols];
    if (token) {
        const encodedToken = btoa(token).replace(/=/g, '');
        protocols.push(`base64url.bearer.authorization.k8s.io.${encodedToken}`);
    }
    let fullPath = path;
    let url = '';
    if (cluster) {
        fullPath = combinePath(`/${CLUSTERS_PREFIX}/${cluster}`, path);
        try {
            const kubeconfig = await findKubeconfigByClusterName(cluster);
            if (kubeconfig !== null) {
                protocols.push(`base64url.headlamp.authorization.k8s.io.${userID}`);
            }
            url = combinePath(BASE_WS_URL, fullPath);
        }
        catch (error) {
            console.error('Error while finding kubeconfig:', error);
            // If we can't find the kubeconfig, we'll just use the base URL.
            url = combinePath(BASE_WS_URL, fullPath);
        }
    }
    let socket = null;
    try {
        socket = new WebSocket(url, protocols);
        socket.binaryType = 'arraybuffer';
        socket.addEventListener('message', onMessage);
        socket.addEventListener('close', onClose);
        socket.addEventListener('error', onError);
    }
    catch (error) {
        console.error(error);
    }
    return { close, socket };
    function close() {
        isClosing = true;
        if (!socket) {
            return;
        }
        socket.close();
    }
    function onMessage(body) {
        if (isClosing)
            return;
        const item = isJson ? JSON.parse(body.data) : body.data;
        if (isDebugVerbose('k8s/apiProxy@connectStream onMessage cb(item)')) {
            console.debug('k8s/apiProxy@connectStream onMessage cb(item)', { item });
        }
        cb(item);
    }
    function onClose(...args) {
        if (isClosing)
            return;
        isClosing = true;
        if (!socket) {
            return;
        }
        if (socket) {
            socket.removeEventListener('message', onMessage);
            socket.removeEventListener('close', onClose);
            socket.removeEventListener('error', onError);
        }
        console.warn('Socket closed unexpectedly', { path, args });
        onFail();
    }
    function onError(err) {
        console.error('Error in api stream', { err, path });
    }
}
