import { useQueries, useQueryClient } from '@tanstack/react-query';
import { useMemo, useState } from 'react';
import { clusterFetch } from './fetch';
import { useEndpoints } from './hooks';
import { KubeList } from './KubeList';
import { KubeObjectEndpoint } from './KubeObjectEndpoint';
import { makeUrl } from './makeUrl';
import { useWebSockets } from './webSocket';
/**
 * Error thrown when listing Kube objects
 * Contains information about the cluster and namespace
 */
class ListError extends Error {
    constructor(message, cluster, namespace) {
        super(message);
        this.message = message;
        this.cluster = cluster;
        this.namespace = namespace;
    }
}
/**
 * Query to list Kube objects from a cluster and namespace(optional)
 *
 * @param kubeObjectClass - Class to instantiate the object with
 * @param endpoint - API endpoint
 * @param namespace - namespace to list objects from(optional)
 * @param cluster - cluster name
 * @param queryParams - query parameters
 * @returns query options for getting a single list of kube resources
 */
export function kubeObjectListQuery(kubeObjectClass, endpoint, namespace, cluster, queryParams) {
    return {
        placeholderData: null,
        queryKey: [
            'kubeObject',
            'list',
            kubeObjectClass.apiVersion,
            kubeObjectClass.apiName,
            cluster,
            namespace ?? '',
            queryParams,
        ],
        queryFn: async () => {
            // If no valid endpoint is passed, don't make the request
            if (!endpoint)
                return;
            try {
                const list = await clusterFetch(makeUrl([KubeObjectEndpoint.toUrl(endpoint, namespace)], queryParams), {
                    cluster,
                }).then(it => it.json());
                list.items = list.items.map(item => {
                    const itm = new kubeObjectClass({ ...item, kind: list.kind.replace('List', '') });
                    itm.cluster = cluster;
                    return itm;
                });
                const response = {
                    list: list,
                    cluster,
                    namespace,
                };
                return response;
            }
            catch (e) {
                // Rethrow error with cluster and namespace information
                throw new ListError(e, cluster, namespace);
            }
        },
    };
}
/**
 * Accepts a list of lists to watch.
 * Upon receiving update it will modify query data for list query
 */
function useWatchKubeObjectLists({ kubeObjectClass, endpoint, lists, queryParams, }) {
    const client = useQueryClient();
    const connections = useMemo(() => {
        if (!endpoint)
            return [];
        return lists.map(({ cluster, namespace, resourceVersion }) => {
            const url = makeUrl([KubeObjectEndpoint.toUrl(endpoint, namespace)], {
                ...queryParams,
                watch: 1,
                resourceVersion,
            });
            return {
                cluster,
                url,
                onMessage(update) {
                    const key = kubeObjectListQuery(kubeObjectClass, endpoint, namespace, cluster, queryParams ?? {}).queryKey;
                    client.setQueryData(key, (oldResponse) => {
                        if (!oldResponse)
                            return oldResponse;
                        const newList = KubeList.applyUpdate(oldResponse.list, update, kubeObjectClass);
                        return { ...oldResponse, list: newList };
                    });
                },
            };
        });
    }, [lists, kubeObjectClass, endpoint]);
    useWebSockets({
        enabled: !!endpoint,
        connections,
    });
}
/**
 * Creates multiple requests to list Kube objects
 * Handles multiple clusters, namespaces and allowed namespaces
 *
 * @param clusters - list of clusters
 * @param getAllowedNamespaces -  function to get allowed namespaces for a cluster
 * @param isResourceNamespaced - if the resource is namespaced
 * @param requestedNamespaces - requested namespaces(optional)
 *
 * @returns list of requests for clusters and appropriate namespaces
 */
export function makeListRequests(clusters, getAllowedNamespaces, isResourceNamespaced, requestedNamespaces) {
    return clusters.map(cluster => {
        const allowedNamespaces = getAllowedNamespaces(cluster);
        let namespaces = requestedNamespaces ?? allowedNamespaces;
        if (allowedNamespaces.length) {
            namespaces = namespaces.filter(ns => allowedNamespaces.includes(ns));
        }
        return { cluster, namespaces: isResourceNamespaced ? namespaces : undefined };
    });
}
/**
 * Returns a combined list of Kubernetes objects and watches for changes from the clusters given.
 *
 * @param param - request paramaters
 * @returns Combined list of Kubernetes resources
 */
export function useKubeObjectList({ requests, kubeObjectClass, queryParams, watch = true, }) {
    const maybeNamespace = requests.find(it => it.namespaces)?.namespaces?.[0];
    // Get working endpoint from the first cluster
    // Now if clusters have different apiVersions for the same resource for example, this will not work
    const endpoint = useEndpoints(kubeObjectClass.apiEndpoint.apiInfo, requests[0]?.cluster, maybeNamespace);
    const cleanedUpQueryParams = Object.fromEntries(Object.entries(queryParams ?? {}).filter(([, value]) => value !== undefined && value !== ''));
    const queries = useMemo(() => endpoint
        ? requests.flatMap(({ cluster, namespaces }) => namespaces && namespaces.length > 0
            ? namespaces.map(namespace => kubeObjectListQuery(kubeObjectClass, endpoint, namespace, cluster, cleanedUpQueryParams))
            : kubeObjectListQuery(kubeObjectClass, endpoint, undefined, cluster, cleanedUpQueryParams))
        : [], [requests, kubeObjectClass, endpoint, cleanedUpQueryParams]);
    const query = useQueries({
        queries,
        combine(results) {
            return {
                data: results.map(result => result.data),
                clusterResults: results.reduce((acc, result) => {
                    if (result.data && result.data.cluster) {
                        acc[result.data.cluster] = {
                            data: result.data,
                            error: result.error,
                            isError: result.isError,
                            isFetching: result.isFetching,
                            isLoading: result.isLoading,
                            isSuccess: result.isSuccess,
                            items: result?.data?.list?.items ?? null,
                            status: result.status,
                        };
                    }
                    return acc;
                }, {}),
                items: results.every(result => result.data === null)
                    ? null
                    : results.flatMap(result => result?.data?.list?.items ?? []),
                errors: results.map(result => result.error),
                clusterErrors: results
                    .filter(result => result.error)
                    .reduce((acc, result) => {
                    if (result.error) {
                        acc[result.error.cluster] = result.error;
                    }
                    return acc;
                }, {}),
                isError: results.some(result => result.isError),
                isLoading: results.some(result => result.isLoading),
                isFetching: results.some(result => result.isFetching),
                isSuccess: results.every(result => result.isSuccess),
            };
        },
    });
    const shouldWatch = watch && !query.isLoading;
    const [listsToWatch, setListsToWatch] = useState([]);
    const listsNotYetWatched = query.data
        .filter(Boolean)
        .filter(data => listsToWatch.find(
    // resourceVersion is intentionally omitted to avoid recreating WS connection when list is updated
    watching => watching.cluster === data?.cluster && watching.namespace === data.namespace) === undefined)
        .map(data => ({
        cluster: data.cluster,
        namespace: data.namespace,
        resourceVersion: data.list.metadata.resourceVersion,
    }));
    if (listsNotYetWatched.length > 0) {
        setListsToWatch([...listsToWatch, ...listsNotYetWatched]);
    }
    useWatchKubeObjectLists({
        lists: shouldWatch ? listsToWatch : [],
        endpoint,
        kubeObjectClass,
        queryParams: cleanedUpQueryParams,
    });
    // @ts-ignore - TS compiler gets confused with iterators
    return {
        items: query.items,
        clusterResults: query.clusterResults,
        clusterErrors: query.clusterErrors,
        isError: query.isError,
        isLoading: query.isLoading,
        isFetching: query.isFetching,
        isSuccess: query.isSuccess,
        *[Symbol.iterator]() {
            yield query.items;
            yield query.errors[0];
        },
    };
}
