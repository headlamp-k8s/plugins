import { ResourceClasses } from '.';
import { apiFactory, apiFactoryWithNamespace } from './apiProxy';
import { KubeObject } from './KubeObject';
class CustomResourceDefinition extends KubeObject {
    static get listRoute() {
        return 'crds';
    }
    static get detailsRoute() {
        return 'crd';
    }
    get spec() {
        return this.jsonData.spec;
    }
    get status() {
        return this.jsonData.status;
    }
    get plural() {
        return this.spec.names.plural;
    }
    getMainAPIGroup() {
        const group = this.spec.group;
        let version = this.spec.version;
        const name = this.spec.names.plural;
        // Assign the 1st storage version if no version is specified,
        // or the 1st served version if no storage version is specified.
        if (!version && this.spec.versions.length > 0) {
            for (const versionItem of this.spec.versions) {
                if (!!versionItem.storage) {
                    version = versionItem.name;
                }
                else if (!version) {
                    version = versionItem.name;
                }
            }
        }
        return [group, version, name];
    }
    get isNamespacedScope() {
        return this.spec.scope === 'Namespaced';
    }
    makeCRClass() {
        const apiInfo = this.jsonData.spec.versions.map(versionInfo => ({ group: this.spec.group, version: versionInfo.name }));
        return makeCustomResourceClass({
            apiInfo,
            isNamespaced: this.spec.scope === 'Namespaced',
            singularName: this.spec.names.singular,
            pluralName: this.spec.names.plural,
        });
    }
    getCategories() {
        return this.status?.acceptedNames?.categories ?? [];
    }
}
CustomResourceDefinition.kind = 'CustomResourceDefinition';
CustomResourceDefinition.apiName = 'customresourcedefinitions';
CustomResourceDefinition.apiVersion = ['apiextensions.k8s.io/v1', 'apiextensions.k8s.io/v1beta1'];
CustomResourceDefinition.isNamespaced = false;
CustomResourceDefinition.readOnlyFields = ['metadata.managedFields'];
export function makeCustomResourceClass(args, isNamespaced) {
    var _a;
    let apiInfoArgs = [];
    if (Array.isArray(args)) {
        apiInfoArgs = args;
    }
    else {
        apiInfoArgs = args.apiInfo.map(info => [info.group, info.version, args.pluralName]);
    }
    // Used for tests
    if (import.meta.env.UNDER_TEST || import.meta.env.STORYBOOK) {
        const knownClass = ResourceClasses[apiInfoArgs[0][2]];
        if (!!knownClass) {
            return knownClass;
        }
    }
    const crClassArgs = args;
    const objArgs = {
        isNamespaced: !!isNamespaced || crClassArgs.isNamespaced,
        singleName: crClassArgs.singularName || 'crd',
    };
    const apiFunc = !!objArgs.isNamespaced ? apiFactoryWithNamespace : apiFactory;
    return _a = class CRClass extends KubeObject {
        },
        _a.kind = objArgs.singleName,
        _a.apiName = crClassArgs.pluralName,
        _a.apiVersion = apiInfoArgs.map(([group, version]) => group ? `${group}/${version}` : version),
        _a.apiEndpoint = apiFunc(...apiInfoArgs),
        _a;
}
export default CustomResourceDefinition;
