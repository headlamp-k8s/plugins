/**
 * @todo: A summary of things marked for fixing in this file marked with todo:
 *
 * - Return types are missing in places.
 * - Some types are "any".
 * - No docs on some functions and interfaces.
 * - Async is missing on some functions that need to be marked as so.
 * - Some of the users of the functions are not handling errors.
 *
 * Additionally, it needs to be refactored into an apiProxy/ folder, with the
 * functionality broken up into smaller files by topic/feature. Keeping the
 * apiProxy/index.ts file as the entry point for backwards compatibility
 * exporting everything from there.
 */
import { OpPatch } from 'json-patch';
import { KubeMetadata, KubeMetrics, KubeObjectInterface } from './cluster';
/**
 * Options for the request.
 */
export interface RequestParams extends RequestInit {
    /** Number of milliseconds to wait for a response. */
    timeout?: number;
    /** Is the request expected to receive JSON data? */
    isJSON?: boolean;
    /** Cluster context name. */
    cluster?: string | null;
    /** Whether to automatically log out the user if there is an authentication error. */
    autoLogoutOnAuthError?: boolean;
}
export interface ClusterRequest {
    /** The name of the cluster (has to be unique, or it will override an existing cluster) */
    name?: string;
    /** The cluster URL */
    server?: string;
    /** Whether the server's certificate should not be checked for validity */
    insecureTLSVerify?: boolean;
    /** The certificate authority data */
    certificateAuthorityData?: string;
    /** KubeConfig (base64 encoded)*/
    kubeconfig?: string;
}
/**
 * QueryParamaters is a map of query parameters for the Kubernetes API.
 */
export interface QueryParameters {
    /**
     * Continue token for paging through large result sets.
     *
     * The continue option should be set when retrieving more results from the server.
     * Since this value is server defined, clients may only use the continue value
     * from a previous query result with identical query parameters
     * (except for the value of continue) and the server may reject a continue value
     * it does not recognize. If the specified continue value is no longer valid
     * whether due to expiration (generally five to fifteen minutes) or a
     * configuration change on the server, the server will respond with a
     * 410 ResourceExpired error together with a continue token. If the client
     * needs a consistent list, it must restart their list without the continue field.
     * Otherwise, the client may send another list request with the token received
     * with the 410 error, the server will respond with a list starting from the next
     * key, but from the latest snapshot, which is inconsistent from the previous
     * list results - objects that are created, modified, or deleted after the first
     * list request will be included in the response, as long as their keys are after
     * the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from
     * the last resourceVersion value returned by the server and not miss any modifications.
     * @see https://kubernetes.io/docs/reference/using-api/api-concepts/#retrieving-large-results-sets-in-chunks
     */
    continue?: string;
    /**
     * dryRun causes apiserver to simulate the request, and report whether the object would be modified.
     * Can be '' or 'All'
     *
     * @see https://kubernetes.io/docs/reference/using-api/api-concepts/#dry-run
     */
    dryRun?: string;
    /**
     * fieldSeletor restricts the list of returned objects by their fields. Defaults to everything.
     *
     * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/
     */
    fieldSelector?: string;
    /**
     * labelSelector restricts the list of returned objects by their labels. Defaults to everything.
     *
     * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
     * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call.
     *
     * If more items exist, the server will set the continue field on the list
     * metadata to a value that can be used with the same initial query to retrieve
     * the next set of results. Setting a limit may return fewer than the requested
     * amount of items (up to zero items) in the event all requested objects are
     * filtered out and clients should only use the presence of the continue field
     * to determine whether more results are available. Servers may choose not to
     * support the limit argument and will return all of the available results.
     * If limit is specified and the continue field is empty, clients may assume
     * that no more results are available.
     *
     * This field is not supported if watch is true.
     * @see https://kubernetes.io/docs/reference/using-api/api-concepts/#retrieving-large-results-sets-in-chunks
     */
    limit?: string | number;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from.
     * Defaults to unset
     *
     * @see https://kubernetes.io/docs/reference/using-api/api-concepts/#efficient-detection-of-changes
     * @see https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
     */
    resourceVersion?: string;
    /**
     * allowWatchBookmarks means watch events with type "BOOKMARK" will also be sent.
     *
     * Can be 'true'
     * @see https://kubernetes.io/docs/reference/using-api/api-concepts/#watch-bookmarks
     */
    allowWatchBookmarks?: string;
    /**
     * sendInitialEvents controls whether the server will send the events
     * for a watch before sending the current list state.
     *
     * Can be 'true'.
     * @see https://kubernetes.io/docs/reference/using-api/api-concepts/#streaming-lists
     */
    sendInitialEvents?: string;
    /**
     * The resource version to match.
     *
     * @see https://kubernetes.io/docs/reference/using-api/api-concepts/#semantics-for-get-and-list
     */
    resourceVersionMatch?: string;
    /**
     * If 'true', then the output is pretty printed.
     * Can be '' or 'true'
     * @see https://kubernetes.io/docs/reference/using-api/api-concepts/#output-options
     */
    pretty?: string;
    /**
     * watch instead of a list or get, watch for changes to the requested object(s).
     *
     * Can be 1.
     * @see https://kubernetes.io/docs/reference/using-api/api-concepts/#efficient-detection-of-changes
     */
    watch?: string;
}
/**
 * Sends a request to the backend. If the useCluster parameter is true (which it is, by default), it will be
 * treated as a request to the Kubernetes server of the currently defined (in the URL) cluster.
 *
 * @param path - The path to the API endpoint.
 * @param params - Optional parameters for the request.
 * @param autoLogoutOnAuthError - Whether to automatically log out the user if there is an authentication error.
 * @param useCluster - Whether to use the current cluster for the request.
 * @param queryParams - Optional query parameters for the request.
 *
 * @returns A Promise that resolves to the JSON response from the API server.
 * @throws An ApiError if the response status is not ok.
 */
export declare function request(path: string, params?: RequestParams, autoLogoutOnAuthError?: boolean, useCluster?: boolean, queryParams?: QueryParameters): Promise<any>;
/**
 * The options for `clusterRequest`.
 */
export interface ClusterRequestParams extends RequestParams {
    cluster?: string | null;
    autoLogoutOnAuthError?: boolean;
}
/**
 * Sends a request to the backend. If the cluster is required in the params parameter, it will
 * be used as a request to the respective Kubernetes server.
 *
 * @param path - The path to the API endpoint.
 * @param params - Optional parameters for the request.
 * @param queryParams - Optional query parameters for the k8s request.
 *
 * @returns A Promise that resolves to the JSON response from the API server.
 * @throws An ApiError if the response status is not ok.
 */
export declare function clusterRequest(path: string, params?: ClusterRequestParams, queryParams?: QueryParameters): Promise<any>;
/** The callback that's called when some results are streamed in. */
export type StreamResultsCb = (...args: any[]) => void;
/** The callback that's called when there's an error streaming the results. */
export type StreamErrCb = (err: Error & {
    status?: number;
}, cancelStreamFunc?: () => void) => void;
/**
 * Creates an API client for a single or multiple Kubernetes resources.
 *
 * @param args - The arguments to pass to either `singleApiFactory` or `multipleApiFactory`.
 *
 * @returns An API client for the specified Kubernetes resource(s).
 */
export declare function apiFactory(...args: Parameters<typeof singleApiFactory> | Parameters<typeof multipleApiFactory>): {
    list: (cb: StreamResultsCb, errCb: StreamErrCb, queryParams?: QueryParameters, cluster?: string) => Promise<() => void>;
    get: (name: string, cb: StreamResultsCb, errCb: StreamErrCb, queryParams?: QueryParameters, cluster?: string) => Promise<() => void>;
    post: (body: JSON | object | KubeObjectInterface, queryParams?: QueryParameters, cluster?: string) => Promise<any>;
    put: (body: KubeObjectInterface, queryParams?: QueryParameters, cluster?: string) => Promise<any>;
    patch: (body: OpPatch[], name: string, queryParams?: QueryParameters, cluster?: string) => Promise<any>;
    delete: (name: string, queryParams?: QueryParameters, cluster?: string) => Promise<any>;
    isNamespaced: boolean;
    apiInfo: {
        group: string;
        version: string;
        resource: string;
    }[];
};
/**
 * Creates an API endpoint object for multiple API endpoints.
 * It first tries the first endpoint, then the second, and so on until it
 * gets a successful response.
 *
 * @param args - An array of arguments to pass to the `singleApiFactory` function.
 *
 * @returns An API endpoint object.
 */
declare function multipleApiFactory(...args: Parameters<typeof singleApiFactory>[]): ReturnType<typeof singleApiFactory>;
/**
 * Describes the API for a certain resource.
 */
export interface ApiInfo {
    /** The API group. */
    group: string;
    /** The API version. */
    version: string;
    /** The resource name. */
    resource: string;
}
/**
 * @returns An object with methods for interacting with a single API endpoint.
 *
 * @param group - The API group.
 * @param version - The API version.
 * @param resource - The API resource.
 */
declare function singleApiFactory(group: string, version: string, resource: string): {
    list: (cb: StreamResultsCb, errCb: StreamErrCb, queryParams?: QueryParameters, cluster?: string) => Promise<() => void>;
    get: (name: string, cb: StreamResultsCb, errCb: StreamErrCb, queryParams?: QueryParameters, cluster?: string) => Promise<() => void>;
    post: (body: JSON | object | KubeObjectInterface, queryParams?: QueryParameters, cluster?: string) => Promise<any>;
    put: (body: KubeObjectInterface, queryParams?: QueryParameters, cluster?: string) => Promise<any>;
    patch: (body: OpPatch[], name: string, queryParams?: QueryParameters, cluster?: string) => Promise<any>;
    delete: (name: string, queryParams?: QueryParameters, cluster?: string) => Promise<any>;
    isNamespaced: boolean;
    apiInfo: {
        group: string;
        version: string;
        resource: string;
    }[];
};
export declare function apiFactoryWithNamespace(...args: Parameters<typeof simpleApiFactoryWithNamespace> | Parameters<typeof multipleApiFactoryWithNamespace>): {
    [other: string]: any;
    scale?: ReturnType<typeof apiScaleFactory>;
};
declare function multipleApiFactoryWithNamespace(...args: Parameters<typeof simpleApiFactoryWithNamespace>[]): ReturnType<typeof simpleApiFactoryWithNamespace>;
declare function simpleApiFactoryWithNamespace(group: string, version: string, resource: string, includeScale?: boolean): {
    [other: string]: any;
    scale?: ReturnType<typeof apiScaleFactory>;
};
declare function apiScaleFactory(apiRoot: string, resource: string): {
    get: (namespace: string, name: string, clusterName?: string) => Promise<any>;
    put: (body: {
        metadata: KubeMetadata;
        spec: {
            replicas: number;
        };
    }, clusterName?: string) => Promise<any>;
    patch: (body: {
        spec: {
            replicas: number;
        };
    }, metadata: KubeMetadata, clusterName?: string) => Promise<any>;
};
export declare function post(url: string, json: JSON | object | KubeObjectInterface, autoLogoutOnAuthError?: boolean, options?: ClusterRequestParams): Promise<any>;
export declare function patch(url: string, json: any, autoLogoutOnAuthError?: boolean, options?: ClusterRequestParams): Promise<any>;
export declare function put(url: string, json: Partial<KubeObjectInterface>, autoLogoutOnAuthError?: boolean, requestOptions?: ClusterRequestParams): Promise<any>;
export declare function remove(url: string, requestOptions?: ClusterRequestParams): Promise<any>;
/**
 * Streams the results of a Kubernetes API request into a 'cb' callback.
 *
 * @param url - The URL of the Kubernetes API endpoint.
 * @param name - The name of the Kubernetes API resource.
 * @param cb - The callback function to execute when the stream receives data.
 * @param errCb - The callback function to execute when an error occurs.
 * @param queryParams - The query parameters to include in the API request.
 *
 * @returns A function to cancel the stream.
 */
export declare function streamResult(url: string, name: string, cb: StreamResultsCb, errCb: StreamErrCb, queryParams?: QueryParameters, cluster?: string): Promise<() => void>;
/**
 * Streams the results of a Kubernetes API request.
 *
 * @param url - The URL of the Kubernetes API endpoint.
 * @param cb - The callback function to execute when the stream receives data.
 * @param errCb - The callback function to execute when an error occurs.
 * @param queryParams - The query parameters to include in the API request.
 *
 * @returns A function to cancel the stream.
 */
export declare function streamResults(url: string, cb: StreamResultsCb, errCb: StreamErrCb, queryParams: QueryParameters | undefined): Promise<() => void>;
export interface StreamResultsParams {
    cb: StreamResultsCb;
    errCb: StreamErrCb;
    cluster?: string;
}
export declare function streamResultsForCluster(url: string, params: StreamResultsParams, queryParams: QueryParameters | undefined): Promise<() => void>;
/**
 * Configure a stream with... StreamArgs.
 */
export interface StreamArgs {
    /** Whether the stream is expected to receive JSON data. */
    isJson?: boolean;
    /** Additional WebSocket protocols to use when connecting. */
    additionalProtocols?: string[];
    /** A callback function to execute when the WebSocket connection is established. */
    connectCb?: () => void;
    /** Whether to attempt to reconnect the WebSocket connection if it fails. */
    reconnectOnFailure?: boolean;
    /** A callback function to execute when the WebSocket connection fails. */
    failCb?: () => void;
    tty?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    stderr?: boolean;
    cluster?: string;
}
/**
 * Establishes a WebSocket connection to the specified URL and streams the results
 * to the provided callback function.
 *
 * @param url - The URL to connect to.
 * @param cb - The callback function to receive the streamed results.
 * @param args - Additional arguments to configure the stream.
 *
 * @returns An object with two functions: `cancel`, which can be called to cancel
 * the stream, and `getSocket`, which returns the WebSocket object.
 */
export declare function stream(url: string, cb: StreamResultsCb, args: StreamArgs): {
    cancel: () => void;
    getSocket: () => WebSocket | null;
};
/**
 * Applies the provided body to the Kubernetes API.
 *
 * Tries to POST, and if there's a conflict it does a PUT to the api endpoint.
 *
 * @param body - The kubernetes object body to apply.
 * @param clusterName - The cluster to apply the body to. By default uses the current cluster (URL defined).
 *
 * @returns The response from the kubernetes API server.
 */
export declare function apply(body: KubeObjectInterface, clusterName?: string): Promise<JSON>;
export interface ApiError extends Error {
    status: number;
}
/**
 * Gets the metrics for the specified resource. Gets new metrics every 10 seconds.
 *
 * @param url - The url of the resource to get metrics for.
 * @param onMetrics - The function to call with the metrics.
 * @param onError - The function to call if there's an error.
 * @param cluster - The cluster to get metrics for. By default uses the current cluster (URL defined).
 *
 * @returns A function to cancel the metrics request.
 */
export declare function metrics(url: string, onMetrics: (arg: KubeMetrics[]) => void, onError?: (err: ApiError) => void, cluster?: string): Promise<() => void>;
export declare function testAuth(cluster?: string, namespace?: string): Promise<any>;
export declare function testClusterHealth(cluster?: string): Promise<any>;
export declare function setCluster(clusterReq: ClusterRequest): Promise<any>;
export declare function deleteCluster(cluster: string): Promise<any>;
/**
 * renameCluster sends call to backend to update a field in kubeconfig which
 * is the custom name of the cluster used by the user.
 * @param cluster
 */
export declare function renameCluster(cluster: string, newClusterName: string, source: string): Promise<any>;
/**
 * parseKubeConfig sends call to backend to parse kubeconfig and send back
 * the parsed clusters and contexts.
 * @param clusterReq - The cluster request object.
 */
export declare function parseKubeConfig(clusterReq: ClusterRequest): Promise<any>;
/**
 * Starts a portforward with the given details.
 *
 * @param cluster - The cluster to portforward for.
 * @param namespace - The namespace to portforward for.
 * @param podname - The pod to portforward for.
 * @param containerPort - The container port to portforward for.
 * @param service - The service to portforward for.
 * @param serviceNamespace - The service namespace to portforward for.
 * @param port - The port to portforward for.
 * @param id - The id to portforward for.
 *
 * @returns The response from the API.
 * @throws {Error} if the request fails.
 */
export declare function startPortForward(cluster: string, namespace: string, podname: string, containerPort: number | string, service: string, serviceNamespace: string, port?: string, address?: string, id?: string): Promise<any>;
/**
 * Stops or deletes a portforward with the specified details.
 *
 * @param cluster - The cluster to portforward for.
 * @param id - The id to portforward for.
 * @param stopOrDelete - Whether to stop or delete the portforward. True for stop, false for delete.
 *
 * @returns The response from the API.
 * @throws {Error} if the request fails.
 */
export declare function stopOrDeletePortForward(cluster: string, id: string, stopOrDelete?: boolean): Promise<string>;
/**
 * Lists the port forwards for the specified cluster.
 *
 * @param cluster - The cluster to list the port forwards.
 *
 * @returns the list of port forwards for the cluster.
 */
export declare function listPortForward(cluster: string): Promise<any>;
/**
 * Drain a node
 *
 * @param cluster - The cluster to drain the node
 * @param nodeName - The node name to drain
 *
 * @returns {Promise<JSON>}
 * @throws {Error} if the request fails
 * @throws {Error} if the response is not ok
 *
 * This function is used to drain a node. It is used in the node detail page.
 * As draining a node is a long running process, we get the request received
 * message if the request is successful. And then we poll the drain node status endpoint
 * to get the status of the drain node process.
 */
export declare function drainNode(cluster: string, nodeName: string): Promise<any>;
interface DrainNodeStatus {
    id: string;
    cluster: string;
}
/**
 * Get the status of the drain node process.
 *
 * It is used in the node detail page.
 * As draining a node is a long running process, we poll this endpoint to get
 * the status of the drain node process.
 *
 * @param cluster - The cluster to get the status of the drain node process for.
 * @param nodeName - The node name to get the status of the drain node process for.
 *
 * @returns - The response from the API. @todo: what response?
 * @throws {Error} if the request fails
 * @throws {Error} if the response is not ok
 */
export declare function drainNodeStatus(cluster: string, nodeName: string): Promise<DrainNodeStatus>;
/**
 * Deletes the plugin with the specified name from the system.
 *
 * This function sends a DELETE request to the server's plugin management
 * endpoint, targeting the plugin identified by its name.
 * The function handles the request asynchronously and returns a promise that
 * resolves with the server's response to the DELETE operation.
 *
 * @param {string} name - The unique name of the plugin to delete.
 *  This identifier is used to construct the URL for the DELETE request.
 *
 * @returns — A Promise that resolves to the JSON response from the API server.
 * @throws — An ApiError if the response status is not ok.
 *
 * @example
 * // Call to delete a plugin named 'examplePlugin'
 * deletePlugin('examplePlugin')
 *   .then(response => console.log('Plugin deleted successfully', response))
 *   .catch(error => console.error('Failed to delete plugin', error));
 */
export declare function deletePlugin(name: string): Promise<any>;
export {};
