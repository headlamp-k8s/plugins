/*
 * This module was originally taken from the K8dash project before modifications.
 *
 * K8dash is licensed under Apache License 2.0.
 *
 * Copyright © 2020 Eric Herbrandson
 * Copyright © 2020 Kinvolk GmbH
 */
import _ from 'lodash';
import { decodeToken } from 'react-jwt';
import helpers, { getHeadlampAPIHeaders, isDebugVerbose } from '../../helpers';
import store from '../../redux/stores/store';
import { deleteClusterKubeconfig, findKubeconfigByClusterName, getUserIdFromLocalStorage, storeStatelessClusterKubeconfig, } from '../../stateless/';
import { getToken, logout, setToken } from '../auth';
import { getCluster } from '../util';
// Uncomment the following lines to enable verbose debug logging in this module.
// import { debugVerbose } from '../../helpers';
// debugVerbose('k8s/apiProxy');
const BASE_HTTP_URL = helpers.getAppUrl();
const BASE_WS_URL = BASE_HTTP_URL.replace('http', 'ws');
const CLUSTERS_PREFIX = 'clusters';
const JSON_HEADERS = { Accept: 'application/json', 'Content-Type': 'application/json' };
const DEFAULT_TIMEOUT = 2 * 60 * 1000; // ms
const MIN_LIFESPAN_FOR_TOKEN_REFRESH = 10; // sec
let isTokenRefreshInProgress = false;
/**
 * Refreshes the token if it is about to expire.
 *
 * @param token - The token to refresh. For null token it just does nothing.
 *
 * @note Sets the token with `setToken` if the token is refreshed.
 * @note Uses global `isTokenRefreshInProgress` to prevent multiple token
 * refreshes at the same time.
 */
async function refreshToken(token) {
    if (!token || isTokenRefreshInProgress) {
        return;
    }
    // decode token
    const decodedToken = decodeToken(token);
    // return if the token doesn't have an expiry time
    if (!decodedToken?.exp) {
        return;
    }
    // convert expiry seconds to date object
    const expiry = decodedToken.exp;
    const now = new Date().valueOf();
    const expDate = new Date(0);
    expDate.setUTCSeconds(expiry);
    // calculate time to expiry in seconds
    const diff = (expDate.valueOf() - now) / 1000;
    // If the token is not about to expire return
    // comparing the time to expiry with the minimum lifespan for a token both in seconds
    if (diff > MIN_LIFESPAN_FOR_TOKEN_REFRESH) {
        return;
    }
    const namespace = (decodedToken && decodedToken['kubernetes.io'] && decodedToken['kubernetes.io']['namespace']) ||
        '';
    const serviceAccountName = (decodedToken &&
        decodedToken['kubernetes.io'] &&
        decodedToken['kubernetes.io']['serviceaccount'] &&
        decodedToken['kubernetes.io']['serviceaccount']['name']) ||
        {};
    const cluster = getCluster();
    if (!cluster || namespace === '' || serviceAccountName === '') {
        return;
    }
    if (isDebugVerbose('k8s/apiProxy@refreshToken')) {
        console.debug('k8s/apiProxy@refreshToken', 'Refreshing token');
    }
    isTokenRefreshInProgress = true;
    let tokenUrl = combinePath(BASE_HTTP_URL, `/${CLUSTERS_PREFIX}/${cluster}`);
    tokenUrl = combinePath(tokenUrl, `api/v1/namespaces/${namespace}/serviceaccounts/${serviceAccountName}/token`);
    const tokenData = {
        kind: 'TokenRequest',
        apiVersion: 'authentication.k8s.io/v1',
        metadata: { creationTimestamp: null },
        spec: { expirationSeconds: 86400 },
    };
    try {
        const headers = new Headers({
            ...JSON_HEADERS,
        });
        const token = getToken(cluster);
        if (!!token) {
            headers.set('Authorization', `Bearer ${token}`);
        }
        const response = await fetch(tokenUrl, {
            method: 'POST',
            headers,
            body: JSON.stringify(tokenData),
        });
        if (response.status === 201) {
            const token = await response.json();
            setToken(cluster, token.status.token);
        }
        isTokenRefreshInProgress = false;
    }
    catch (err) {
        console.error('Error refreshing token', err);
        isTokenRefreshInProgress = false;
    }
}
/**
 * @returns Auth type of the cluster, or an empty string if the cluster is not found.
 * It could return 'oidc' or '' for example.
 *
 * @param cluster - Name of the cluster.
 */
function getClusterAuthType(cluster) {
    const state = store.getState();
    const authType = state.config?.clusters?.[cluster]?.['auth_type'] || '';
    return authType;
}
/**
 * Sends a request to the backend. If the useCluster parameter is true (which it is, by default), it will be
 * treated as a request to the Kubernetes server of the currently defined (in the URL) cluster.
 *
 * @param path - The path to the API endpoint.
 * @param params - Optional parameters for the request.
 * @param autoLogoutOnAuthError - Whether to automatically log out the user if there is an authentication error.
 * @param useCluster - Whether to use the current cluster for the request.
 * @param queryParams - Optional query parameters for the request.
 *
 * @returns A Promise that resolves to the JSON response from the API server.
 * @throws An ApiError if the response status is not ok.
 */
export async function request(path, params = {}, autoLogoutOnAuthError = true, useCluster = true, queryParams) {
    // @todo: This is a temporary way of getting the current cluster. We should improve it later.
    const cluster = (useCluster && getCluster()) || '';
    if (isDebugVerbose('k8s/apiProxy@request')) {
        console.debug('k8s/apiProxy@request', { path, params, useCluster, queryParams });
    }
    return clusterRequest(path, { cluster, autoLogoutOnAuthError, ...params }, queryParams);
}
/**
 * Sends a request to the backend. If the cluster is required in the params parameter, it will
 * be used as a request to the respective Kubernetes server.
 *
 * @param path - The path to the API endpoint.
 * @param params - Optional parameters for the request.
 * @param queryParams - Optional query parameters for the k8s request.
 *
 * @returns A Promise that resolves to the JSON response from the API server.
 * @throws An ApiError if the response status is not ok.
 */
export async function clusterRequest(path, params = {}, queryParams) {
    const { timeout = DEFAULT_TIMEOUT, cluster: paramsCluster, autoLogoutOnAuthError = true, isJSON = true, ...otherParams } = params;
    const userID = getUserIdFromLocalStorage();
    const opts = Object.assign({ headers: {} }, otherParams);
    const cluster = paramsCluster || '';
    let fullPath = path;
    if (cluster) {
        const token = getToken(cluster);
        const kubeconfig = await findKubeconfigByClusterName(cluster);
        if (kubeconfig !== null) {
            opts.headers['KUBECONFIG'] = kubeconfig;
            opts.headers['X-HEADLAMP-USER-ID'] = userID;
        }
        // Refresh service account token only if the cluster auth type is not OIDC
        if (getClusterAuthType(cluster) !== 'oidc') {
            await refreshToken(token);
        }
        if (!!token) {
            opts.headers.Authorization = `Bearer ${token}`;
        }
        fullPath = combinePath(`/${CLUSTERS_PREFIX}/${cluster}`, path);
    }
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    let url = combinePath(BASE_HTTP_URL, fullPath);
    url += asQuery(queryParams);
    const requestData = { signal: controller.signal, ...opts };
    let response = new Response(undefined, { status: 502, statusText: 'Unreachable' });
    try {
        response = await fetch(url, requestData);
    }
    catch (err) {
        if (err instanceof Error) {
            if (err.name === 'AbortError') {
                response = new Response(undefined, { status: 408, statusText: 'Request timed-out' });
            }
        }
    }
    finally {
        clearTimeout(id);
    }
    // The backend signals through this header that it wants a reload.
    // See plugins.go
    const headerVal = response.headers.get('X-Reload');
    if (headerVal && headerVal.indexOf('reload') !== -1) {
        window.location.reload();
    }
    // In case of OIDC auth if the token is about to expire the backend
    // sends a refreshed token in the response header.
    const newToken = response.headers.get('X-Authorization');
    if (newToken) {
        setToken(cluster, newToken);
    }
    if (!response.ok) {
        const { status, statusText } = response;
        if (autoLogoutOnAuthError && status === 401 && opts.headers.Authorization) {
            console.error('Logging out due to auth error', { status, statusText, path });
            logout();
        }
        let message = statusText;
        try {
            if (isJSON) {
                const json = await response.json();
                message += ` - ${json.message}`;
            }
        }
        catch (err) {
            console.error('Unable to parse error json at url:', url, { err }, 'with request data:', requestData);
        }
        const error = new Error(message);
        error.status = status;
        return Promise.reject(error);
    }
    if (!isJSON) {
        return Promise.resolve(response);
    }
    return response.json();
}
// @todo: repeatStreamFunc could be improved for performance by remembering when a URL
//       is 404 and not trying it again... and again.
/**
 * Repeats a streaming function call across multiple API endpoints until a
 * successful response is received or all endpoints have been exhausted.
 *
 * This is especially useful for Kubernetes beta APIs that then stabalize.
 * So the APIs are available at different endpoints on different versions of Kubernetes.
 *
 * @param apiEndpoints - An array of API endpoint objects returned by the `apiFactory` function.
 * @param funcName - The name of the streaming function to call on each endpoint.
 * @param errCb - A callback function to handle errors that occur during the streaming function call.
 * @param args - Additional arguments to pass to the streaming function.
 *
 * @returns A function that cancels the streaming function call.
 */
async function repeatStreamFunc(apiEndpoints, funcName, errCb, ...args) {
    let isCancelled = false;
    let streamCancel = () => { };
    if (isDebugVerbose('k8s/apiProxy@repeatStreamFunc')) {
        console.debug('k8s/apiProxy@repeatStreamFunc', { apiEndpoints, funcName, args });
    }
    function runStreamFunc(endpointIndex, funcName, errCb, ...args) {
        const endpoint = apiEndpoints[endpointIndex];
        const fullArgs = [...args];
        let errCbIndex = funcName === 'get' ? 2 : 1;
        if (endpoint.isNamespaced) {
            ++errCbIndex;
        }
        fullArgs.splice(errCbIndex, 0, errCb);
        return endpoint[funcName](...fullArgs);
    }
    let endpointIndex = 0;
    const cancel = async (err, cancelStream) => {
        if (isCancelled) {
            return;
        }
        if (err.status === 404 && endpointIndex < apiEndpoints.length) {
            // Cancel current stream
            if (cancelStream) {
                cancelStream();
            }
            streamCancel = await runStreamFunc(endpointIndex++, funcName, cancel, ...args);
        }
        else if (!!errCb) {
            errCb(err, streamCancel);
        }
    };
    streamCancel = await runStreamFunc(endpointIndex++, funcName, cancel, ...args);
    return () => {
        isCancelled = true;
        streamCancel();
    };
}
/**
 * Repeats a factory method call across multiple API endpoints until a
 * successful response is received or all endpoints have been exhausted.
 *
 * This is especially useful for Kubernetes beta APIs that then stabalize.
 * @param apiEndpoints - An array of API endpoint objects returned by the `apiFactory` function.
 * @param funcName - The name of the factory method to call on each endpoint.
 *
 * @returns A function that cancels the factory method call.
 */
function repeatFactoryMethod(apiEndpoints, funcName) {
    return async (...args) => {
        for (let i = 0; i < apiEndpoints.length; i++) {
            try {
                const endpoint = apiEndpoints[i];
                return await endpoint[funcName](...args);
            }
            catch (err) {
                // If the error is 404 and we still have other endpoints, then try the next one
                if (err.status === 404 && i !== apiEndpoints.length - 1) {
                    continue;
                }
                throw err;
            }
        }
    };
}
// @todo: in apiFactory, and multipleApiFactory use rather than 'args'...
//        `group: string, version: string, resource: string`
/**
 * Creates an API client for a single or multiple Kubernetes resources.
 *
 * @param args - The arguments to pass to either `singleApiFactory` or `multipleApiFactory`.
 *
 * @returns An API client for the specified Kubernetes resource(s).
 */
export function apiFactory(...args) {
    if (isDebugVerbose('k8s/apiProxy@apiFactory')) {
        console.debug('k8s/apiProxy@apiFactory', { args });
    }
    if (args[0] instanceof Array) {
        return multipleApiFactory(...args);
    }
    return singleApiFactory(...args);
}
/**
 * Creates an API endpoint object for multiple API endpoints.
 * It first tries the first endpoint, then the second, and so on until it
 * gets a successful response.
 *
 * @param args - An array of arguments to pass to the `singleApiFactory` function.
 *
 * @returns An API endpoint object.
 */
function multipleApiFactory(...args) {
    if (isDebugVerbose('k8s/apiProxy@multipleApiFactory')) {
        console.debug('k8s/apiProxy@multipleApiFactory', { args });
    }
    const apiEndpoints = args.map(apiArgs => singleApiFactory(...apiArgs));
    return {
        list: (cb, errCb, queryParams, cluster) => {
            return repeatStreamFunc(apiEndpoints, 'list', errCb, cb, queryParams, cluster);
        },
        get: (name, cb, errCb, queryParams, cluster) => repeatStreamFunc(apiEndpoints, 'get', errCb, name, cb, queryParams, cluster),
        post: repeatFactoryMethod(apiEndpoints, 'post'),
        patch: repeatFactoryMethod(apiEndpoints, 'patch'),
        put: repeatFactoryMethod(apiEndpoints, 'put'),
        delete: repeatFactoryMethod(apiEndpoints, 'delete'),
        isNamespaced: false,
        apiInfo: args.map(apiArgs => ({
            group: apiArgs[0],
            version: apiArgs[1],
            resource: apiArgs[2],
        })),
    };
}
// @todo: singleApiFactory should have a return type rather than just what it returns.
/**
 * @returns An object with methods for interacting with a single API endpoint.
 *
 * @param group - The API group.
 * @param version - The API version.
 * @param resource - The API resource.
 */
function singleApiFactory(group, version, resource) {
    if (isDebugVerbose('k8s/apiProxy@singleApiFactory')) {
        console.debug('k8s/apiProxy@singleApiFactory', { group, version, resource });
    }
    const apiRoot = getApiRoot(group, version);
    const url = `${apiRoot}/${resource}`;
    return {
        list: (cb, errCb, queryParams, cluster) => {
            if (isDebugVerbose('k8s/apiProxy@singleApiFactory list')) {
                console.debug('k8s/apiProxy@singleApiFactory list', { cluster, queryParams });
            }
            return streamResultsForCluster(url, { cb, errCb, cluster }, queryParams);
        },
        get: (name, cb, errCb, queryParams, cluster) => streamResult(url, name, cb, errCb, queryParams, cluster),
        post: (body, queryParams, cluster) => post(url + asQuery(queryParams), body, true, { cluster }),
        put: (body, queryParams, cluster) => put(`${url}/${body.metadata.name}` + asQuery(queryParams), body, true, { cluster }),
        patch: (body, name, queryParams, cluster) => patch(`${url}/${name}` + asQuery({ ...queryParams, ...{ pretty: 'true' } }), body, true, {
            cluster,
        }),
        delete: (name, queryParams, cluster) => remove(`${url}/${name}` + asQuery(queryParams), { cluster }),
        isNamespaced: false,
        apiInfo: [{ group, version, resource }],
    };
}
// @todo: just use args from simpleApiFactoryWithNamespace, rather than `args`?
//        group: string, version: string, resource: string, includeScale: boolean = false
export function apiFactoryWithNamespace(...args) {
    if (args[0] instanceof Array) {
        return multipleApiFactoryWithNamespace(...args);
    }
    return simpleApiFactoryWithNamespace(...args);
}
function multipleApiFactoryWithNamespace(...args) {
    const apiEndpoints = args.map(apiArgs => simpleApiFactoryWithNamespace(...apiArgs));
    return {
        list: (namespace, cb, errCb, queryParams, cluster) => {
            return repeatStreamFunc(apiEndpoints, 'list', errCb, namespace, cb, queryParams, cluster);
        },
        get: (namespace, name, cb, errCb, queryParams, cluster) => repeatStreamFunc(apiEndpoints, 'get', errCb, namespace, name, cb, queryParams, cluster),
        post: repeatFactoryMethod(apiEndpoints, 'post'),
        patch: repeatFactoryMethod(apiEndpoints, 'patch'),
        put: repeatFactoryMethod(apiEndpoints, 'put'),
        delete: repeatFactoryMethod(apiEndpoints, 'delete'),
        isNamespaced: true,
        apiInfo: args.map(apiArgs => ({
            group: apiArgs[0],
            version: apiArgs[1],
            resource: apiArgs[2],
        })),
    };
}
function simpleApiFactoryWithNamespace(group, version, resource, includeScale = false) {
    if (isDebugVerbose('k8s/apiProxy@simpleApiFactoryWithNamespace')) {
        console.debug('k8s/apiProxy@simpleApiFactoryWithNamespace', {
            group,
            version,
            resource,
            includeScale,
        });
    }
    const apiRoot = getApiRoot(group, version);
    const results = {
        list: (namespace, cb, errCb, queryParams, cluster) => {
            if (isDebugVerbose('k8s/apiProxy@simpleApiFactoryWithNamespace list')) {
                console.debug('k8s/apiProxy@simpleApiFactoryWithNamespace list', { cluster, queryParams });
            }
            return streamResultsForCluster(url(namespace), { cb, errCb, cluster }, queryParams);
        },
        get: (namespace, name, cb, errCb, queryParams, cluster) => streamResult(url(namespace), name, cb, errCb, queryParams, cluster),
        post: (body, queryParams, cluster) => post(url(body.metadata.namespace) + asQuery(queryParams), body, true, { cluster }),
        patch: (body, namespace, name, queryParams, cluster) => patch(`${url(namespace)}/${name}` + asQuery({ ...queryParams, ...{ pretty: 'true' } }), body, true, { cluster }),
        put: (body, queryParams, cluster) => put(`${url(body.metadata.namespace)}/${body.metadata.name}` + asQuery(queryParams), body, true, { cluster }),
        delete: (namespace, name, queryParams, cluster) => remove(`${url(namespace)}/${name}` + asQuery(queryParams), { cluster }),
        isNamespaced: true,
        apiInfo: [{ group, version, resource }],
    };
    if (includeScale) {
        results.scale = apiScaleFactory(apiRoot, resource);
    }
    return results;
    function url(namespace) {
        return namespace ? `${apiRoot}/namespaces/${namespace}/${resource}` : `${apiRoot}/${resource}`;
    }
}
/**
 * Converts k8s queryParams to a URL query string.
 *
 * @param queryParams - The k8s API query parameters to convert.
 * @returns The query string (starting with '?'), or empty string.
 */
function asQuery(queryParams) {
    if (queryParams === undefined) {
        return '';
    }
    let newQueryParams;
    if (typeof queryParams.limit === 'number' || typeof queryParams.limit === 'string') {
        newQueryParams = {
            ...queryParams,
            limit: typeof queryParams.limit === 'number' ? queryParams.limit.toString() : queryParams.limit,
        };
    }
    else {
        newQueryParams = { ..._.omit(queryParams, 'limit') };
    }
    return !!newQueryParams && !!Object.keys(newQueryParams).length
        ? '?' + new URLSearchParams(newQueryParams).toString()
        : '';
}
async function resourceDefToApiFactory(resourceDef, clusterName) {
    if (isDebugVerbose('k8s/apiProxy@resourceDefToApiFactory')) {
        console.debug('k8s/apiProxy@resourceDefToApiFactory', { resourceDef });
    }
    if (!resourceDef.kind) {
        throw new Error(`Cannot handle unknown resource kind: ${resourceDef.kind}`);
    }
    if (!resourceDef.apiVersion) {
        throw new Error(`Definition ${resourceDef.kind} has no apiVersion`);
    }
    let [apiGroup, apiVersion] = resourceDef.apiVersion.split('/');
    // There may not be an API group [1], which means that the apiGroup variable will
    // actually hold the apiVersion, so we switch them.
    // [1] https://kubernetes.io/docs/reference/using-api/#api-groups
    if (!!apiGroup && !apiVersion) {
        apiVersion = apiGroup;
        apiGroup = '';
    }
    if (!apiVersion) {
        throw new Error(`apiVersion has no version string: ${resourceDef.apiVersion}`);
    }
    const cluster = clusterName || getCluster() || '';
    // Get details about this resource. We could avoid this for known resources, but
    // this way we always get the right plural name and we also avoid eventually getting
    // the wrong "known" resource because e.g. there can be CustomResources with the same
    // kind as a known resource.
    const apiPrefix = !!apiGroup ? 'apis' : 'api';
    const apiResult = await clusterRequest(`/${apiPrefix}/${resourceDef.apiVersion}`, {
        cluster,
        autoLogoutOnAuthError: false,
    });
    if (!apiResult) {
        throw new Error(`Unkown apiVersion: ${resourceDef.apiVersion}`);
    }
    // Get resource
    const resource = apiResult.resources?.find(({ kind }) => kind === resourceDef.kind);
    if (!resource) {
        throw new Error(`Unkown resource kind: ${resourceDef.kind}`);
    }
    const hasNamespace = !!resource.namespaced;
    let factoryFunc = apiFactory;
    if (!!hasNamespace) {
        factoryFunc = apiFactoryWithNamespace;
    }
    return factoryFunc(apiGroup, apiVersion, resource.name);
}
function getApiRoot(group, version) {
    return group ? `/apis/${group}/${version}` : `api/${version}`;
}
function apiScaleFactory(apiRoot, resource) {
    return {
        get: (namespace, name, clusterName) => {
            const cluster = clusterName || getCluster() || '';
            return clusterRequest(url(namespace, name), { cluster });
        },
        put: (body, clusterName) => {
            const cluster = clusterName || getCluster() || '';
            return put(url(body.metadata.namespace, body.metadata.name), body, undefined, { cluster });
        },
        patch: (body, metadata, clusterName) => {
            const cluster = clusterName || getCluster() || '';
            return patch(url(metadata.namespace, metadata.name), body, false, { cluster });
        },
    };
    function url(namespace, name) {
        return `${apiRoot}/namespaces/${namespace}/${resource}/${name}/scale`;
    }
}
export function post(url, json, autoLogoutOnAuthError = true, options = {}) {
    const { cluster: clusterName, ...requestOptions } = options;
    const body = JSON.stringify(json);
    const cluster = clusterName || getCluster() || '';
    return clusterRequest(url, {
        method: 'POST',
        body,
        headers: JSON_HEADERS,
        cluster,
        autoLogoutOnAuthError,
        ...requestOptions,
    });
}
export function patch(url, json, autoLogoutOnAuthError = true, options = {}) {
    const { cluster: clusterName, ...requestOptions } = options;
    const body = JSON.stringify(json);
    const cluster = clusterName || getCluster() || '';
    const opts = {
        method: 'PATCH',
        body,
        headers: { ...JSON_HEADERS, 'Content-Type': 'application/merge-patch+json' },
        autoLogoutOnAuthError,
        cluster,
        ...requestOptions,
    };
    return clusterRequest(url, opts);
}
export function put(url, json, autoLogoutOnAuthError = true, requestOptions = {}) {
    const body = JSON.stringify(json);
    const { cluster: clusterName, ...restOptions } = requestOptions;
    const opts = {
        method: 'PUT',
        body,
        headers: JSON_HEADERS,
        autoLogoutOnAuthError,
        cluster: clusterName || getCluster() || '',
        ...restOptions,
    };
    return clusterRequest(url, opts);
}
export function remove(url, requestOptions = {}) {
    const { cluster: clusterName, ...restOptions } = requestOptions;
    const cluster = clusterName || getCluster() || '';
    const opts = { method: 'DELETE', headers: JSON_HEADERS, cluster, ...restOptions };
    return clusterRequest(url, opts);
}
/**
 * Streams the results of a Kubernetes API request into a 'cb' callback.
 *
 * @param url - The URL of the Kubernetes API endpoint.
 * @param name - The name of the Kubernetes API resource.
 * @param cb - The callback function to execute when the stream receives data.
 * @param errCb - The callback function to execute when an error occurs.
 * @param queryParams - The query parameters to include in the API request.
 *
 * @returns A function to cancel the stream.
 */
export async function streamResult(url, name, cb, errCb, queryParams, cluster) {
    let isCancelled = false;
    let socket;
    const clusterName = cluster || getCluster() || '';
    if (isDebugVerbose('k8s/apiProxy@streamResult')) {
        console.debug('k8s/apiProxy@streamResult', { url, name, queryParams });
    }
    run();
    return cancel;
    async function run() {
        try {
            const item = await clusterRequest(`${url}/${name}` + asQuery(queryParams), {
                cluster: clusterName,
            });
            if (isCancelled)
                return;
            if (isDebugVerbose('k8s/apiProxy@streamResult run cb(item)')) {
                console.debug('k8s/apiProxy@streamResult run cb(item)', { item });
            }
            cb(item);
            const watchUrl = url +
                asQuery({ ...queryParams, ...{ watch: '1', fieldSelector: `metadata.name=${name}` } });
            socket = stream(watchUrl, x => cb(x.object), { isJson: true, cluster: clusterName });
        }
        catch (err) {
            console.error('Error in api request', { err, url });
            // @todo: sometimes errCb is {}, the typing for apiProxy needs improving.
            //        See https://github.com/kinvolk/headlamp/pull/833
            if (errCb && typeof errCb === 'function')
                errCb(err, cancel);
        }
    }
    function cancel() {
        if (isCancelled)
            return;
        isCancelled = true;
        if (socket)
            socket.cancel();
    }
}
// @todo: needs a return type.
/**
 * Streams the results of a Kubernetes API request.
 *
 * @param url - The URL of the Kubernetes API endpoint.
 * @param cb - The callback function to execute when the stream receives data.
 * @param errCb - The callback function to execute when an error occurs.
 * @param queryParams - The query parameters to include in the API request.
 *
 * @returns A function to cancel the stream.
 */
export async function streamResults(url, cb, errCb, queryParams) {
    const cluster = getCluster() || '';
    return streamResultsForCluster(url, { cb, errCb, cluster }, queryParams);
}
// @todo: needs a return type.
// @todo: needs documenting
export async function streamResultsForCluster(url, params, queryParams) {
    const { cb, errCb, cluster = '' } = params;
    const clusterName = cluster || getCluster() || '';
    const results = {};
    let isCancelled = false;
    let socket;
    if (isDebugVerbose('k8s/apiProxy@streamResults')) {
        console.debug('k8s/apiProxy@streamResults', { url, queryParams });
    }
    // -1 means unlimited.
    const maxResources = typeof queryParams?.limit === 'number'
        ? queryParams.limit
        : parseInt(queryParams?.limit ?? '-1');
    run();
    return cancel;
    async function run() {
        try {
            const { kind, items, metadata } = await clusterRequest(url + asQuery(queryParams), {
                cluster: clusterName,
            });
            if (isCancelled)
                return;
            add(items, kind);
            const watchUrl = url +
                asQuery({ ...queryParams, ...{ watch: '1', resourceVersion: metadata.resourceVersion } });
            socket = stream(watchUrl, update, { isJson: true, cluster: clusterName });
        }
        catch (err) {
            console.error('Error in api request', { err, url });
            if (errCb && typeof errCb === 'function') {
                errCb(err, cancel);
            }
        }
    }
    function cancel() {
        if (isCancelled)
            return;
        isCancelled = true;
        if (socket)
            socket.cancel();
    }
    function add(items, kind) {
        const fixedKind = kind.slice(0, -4); // Trim off the word "List" from the end of the string
        for (const item of items) {
            item.kind = fixedKind;
            results[item.metadata.uid] = item;
        }
        push();
    }
    function update({ type, object, }) {
        object.actionType = type; // eslint-disable-line no-param-reassign
        switch (type) {
            case 'ADDED':
                results[object.metadata.uid] = object;
                break;
            case 'MODIFIED': {
                const existing = results[object.metadata.uid];
                if (existing) {
                    if (!existing.metadata.resourceVersion || !object.metadata.resourceVersion) {
                        console.error('Missing resourceVersion in object', object);
                        break;
                    }
                    const currentVersion = parseInt(existing.metadata.resourceVersion, 10);
                    const newVersion = parseInt(object.metadata.resourceVersion, 10);
                    if (currentVersion < newVersion) {
                        Object.assign(existing, object);
                    }
                }
                else {
                    results[object.metadata.uid] = object;
                }
                break;
            }
            case 'DELETED':
                delete results[object.metadata.uid];
                break;
            case 'ERROR':
                console.error('Error in update', { type, object });
                break;
            default:
                console.error('Unknown update type', type);
        }
        push();
    }
    function push() {
        const values = Object.values(results);
        // Limit the number of resources to maxResources. We do this because when we're streaming, the
        // API server will send us all the resources that match the query, without limitting, even if the
        // API params wanted to limit it. So we do the limitting here.
        if (maxResources > 0 && values.length > maxResources) {
            values.sort((a, b) => {
                const aTime = new Date(a.lastTimestamp || a.metadata.creationTimestamp).getTime();
                const bTime = new Date(b.lastTimestamp || b.metadata.creationTimestamp).getTime();
                // Reverse sort, so we have the most recent resources at the beginning of the array.
                return 0 - (aTime - bTime);
            });
            values.splice(0, values.length - maxResources);
        }
        if (isDebugVerbose('k8s/apiProxy@push cb(values)')) {
            console.debug('k8s/apiProxy@push cb(values)', { values });
        }
        cb(values);
    }
}
/**
 * Establishes a WebSocket connection to the specified URL and streams the results
 * to the provided callback function.
 *
 * @param url - The URL to connect to.
 * @param cb - The callback function to receive the streamed results.
 * @param args - Additional arguments to configure the stream.
 *
 * @returns An object with two functions: `cancel`, which can be called to cancel
 * the stream, and `getSocket`, which returns the WebSocket object.
 */
export function stream(url, cb, args) {
    let connection = null;
    let isCancelled = false;
    const { failCb, cluster = '' } = args;
    // We only set reconnectOnFailure as true by default if the failCb has not been provided.
    const { isJson = false, additionalProtocols, connectCb, reconnectOnFailure = !failCb } = args;
    if (isDebugVerbose('k8s/apiProxy@stream')) {
        console.debug('k8s/apiProxy@stream', { url, args });
    }
    connect();
    return { cancel, getSocket };
    function getSocket() {
        return connection ? connection.socket : null;
    }
    function cancel() {
        if (connection)
            connection.close();
        isCancelled = true;
    }
    async function connect() {
        if (connectCb)
            connectCb();
        try {
            connection = await connectStream(url, cb, onFail, isJson, additionalProtocols, cluster);
        }
        catch (error) {
            console.error('Error connecting stream:', error);
            onFail();
        }
    }
    function retryOnFail() {
        if (isCancelled)
            return;
        if (reconnectOnFailure) {
            if (isDebugVerbose('k8s/apiProxy@stream retryOnFail')) {
                console.debug('k8s/apiProxy@stream retryOnFail', 'Reconnecting in 3 seconds', { url });
            }
            setTimeout(connect, 3000);
        }
    }
    function onFail() {
        if (!!failCb) {
            failCb();
        }
        if (reconnectOnFailure) {
            retryOnFail();
        }
    }
}
// @todo: needs a return type.
/**
 * Connects to a WebSocket stream at the specified path and returns an object
 * with a `close` function and a `socket` property. Sends messages to `cb` callback.
 *
 * @param path - The path of the WebSocket stream to connect to.
 * @param cb - The function to call with each message received from the stream.
 * @param onFail - The function to call if the stream is closed unexpectedly.
 * @param isJson - Whether the messages should be parsed as JSON.
 * @param additionalProtocols - An optional array of additional WebSocket protocols to use.
 *
 * @returns An object with a `close` function and a `socket` property.
 */
async function connectStream(path, cb, onFail, isJson, additionalProtocols = [], cluster = '') {
    return connectStreamWithParams(path, cb, onFail, {
        isJson,
        cluster: cluster || getCluster() || '',
        additionalProtocols,
    });
}
/**
 * connectStreamWithParams is a wrapper around connectStream that allows for more
 * flexibility in the parameters that can be passed to the WebSocket connection.
 *
 * This is an async function because it may need to fetch the kubeconfig for the
 * cluster if the cluster is specified in the params. If kubeconfig is found, it
 * sends the X-HEADLAMP-USER-ID header with the user ID from the localStorage.
 * It is sent as a base64url encoded string in protocal format:
 * `base64url.headlamp.authorization.k8s.io.${userID}`.
 *
 * @param path - The path of the WebSocket stream to connect to.
 * @param cb - The function to call with each message received from the stream.
 * @param onFail - The function to call if the stream is closed unexpectedly.
 * @param params - Stream parameters to configure the connection.
 *
 * @returns A promise that resolves to an object with a `close` function and a `socket` property.
 */
async function connectStreamWithParams(path, cb, onFail, params) {
    const { isJson = false, additionalProtocols = [], cluster = '' } = params || {};
    let isClosing = false;
    const token = getToken(cluster || '');
    const userID = getUserIdFromLocalStorage();
    const protocols = ['base64.binary.k8s.io', ...additionalProtocols];
    if (token) {
        const encodedToken = btoa(token).replace(/=/g, '');
        protocols.push(`base64url.bearer.authorization.k8s.io.${encodedToken}`);
    }
    let fullPath = path;
    let url = '';
    if (cluster) {
        fullPath = combinePath(`/${CLUSTERS_PREFIX}/${cluster}`, path);
        try {
            const kubeconfig = await findKubeconfigByClusterName(cluster);
            if (kubeconfig !== null) {
                protocols.push(`base64url.headlamp.authorization.k8s.io.${userID}`);
            }
            url = combinePath(BASE_WS_URL, fullPath);
        }
        catch (error) {
            console.error('Error while finding kubeconfig:', error);
            // If we can't find the kubeconfig, we'll just use the base URL.
            url = combinePath(BASE_WS_URL, fullPath);
        }
    }
    let socket = null;
    try {
        socket = new WebSocket(url, protocols);
        socket.binaryType = 'arraybuffer';
        socket.addEventListener('message', onMessage);
        socket.addEventListener('close', onClose);
        socket.addEventListener('error', onError);
    }
    catch (error) {
        console.error(error);
    }
    return { close, socket };
    function close() {
        isClosing = true;
        if (!socket) {
            return;
        }
        socket.close();
    }
    function onMessage(body) {
        if (isClosing)
            return;
        const item = isJson ? JSON.parse(body.data) : body.data;
        if (isDebugVerbose('k8s/apiProxy@connectStream onMessage cb(item)')) {
            console.debug('k8s/apiProxy@connectStream onMessage cb(item)', { item });
        }
        cb(item);
    }
    function onClose(...args) {
        if (isClosing)
            return;
        isClosing = true;
        if (!socket) {
            return;
        }
        if (socket) {
            socket.removeEventListener('message', onMessage);
            socket.removeEventListener('close', onClose);
            socket.removeEventListener('error', onError);
        }
        console.warn('Socket closed unexpectedly', { path, args });
        onFail();
    }
    function onError(err) {
        console.error('Error in api stream', { err, path });
    }
}
/**
 * Combines a base path and a path to create a full path.
 *
 * Doesn't matter if the start or the end has a single slash, the result will always have a single slash.
 *
 * @param base - The base path.
 * @param path - The path to combine with the base path.
 *
 * @returns The combined path.
 */
function combinePath(base, path) {
    if (base.endsWith('/'))
        base = base.slice(0, -1); // eslint-disable-line no-param-reassign
    if (path.startsWith('/'))
        path = path.slice(1); // eslint-disable-line no-param-reassign
    return `${base}/${path}`;
}
// @todo: apply() and other requests return Promise<any> Can we get it to return a better type?
// @todo: Promise<JSON> doesn't make any sense as a type.
/**
 * Applies the provided body to the Kubernetes API.
 *
 * Tries to POST, and if there's a conflict it does a PUT to the api endpoint.
 *
 * @param body - The kubernetes object body to apply.
 * @param clusterName - The cluster to apply the body to. By default uses the current cluster (URL defined).
 *
 * @returns The response from the kubernetes API server.
 */
export async function apply(body, clusterName) {
    const bodyToApply = _.cloneDeep(body);
    let apiEndpoint;
    try {
        apiEndpoint = await resourceDefToApiFactory(bodyToApply, clusterName);
    }
    catch (err) {
        console.error(`Error getting api endpoint when applying the resource ${bodyToApply}: ${err}`);
        throw err;
    }
    const cluster = clusterName || getCluster();
    // Check if the default namespace is needed. And we need to do this before
    // getting the apiEndpoint because it will affect the endpoint itself.
    const isNamespaced = apiEndpoint.isNamespaced;
    const { namespace } = body.metadata;
    if (!namespace && isNamespaced) {
        let defaultNamespace = 'default';
        if (!!cluster) {
            defaultNamespace = getClusterDefaultNamespace(cluster) || 'default';
        }
        bodyToApply.metadata.namespace = defaultNamespace;
    }
    const resourceVersion = bodyToApply.metadata.resourceVersion;
    try {
        delete bodyToApply.metadata.resourceVersion;
        return await apiEndpoint.post(bodyToApply, {}, cluster);
    }
    catch (err) {
        // Check to see if failed because the record already exists.
        // If the failure isn't a 409 (i.e. Confilct), just rethrow.
        if (err.status !== 409)
            throw err;
        // Preserve the resourceVersion if its an update request
        bodyToApply.metadata.resourceVersion = resourceVersion;
        // We had a conflict. Try a PUT
        return apiEndpoint.put(bodyToApply, {}, cluster);
    }
}
// @todo: is metrics() used anywhere? I can't find so, maybe in a plugin?
/**
 * Gets the metrics for the specified resource. Gets new metrics every 10 seconds.
 *
 * @param url - The url of the resource to get metrics for.
 * @param onMetrics - The function to call with the metrics.
 * @param onError - The function to call if there's an error.
 * @param cluster - The cluster to get metrics for. By default uses the current cluster (URL defined).
 *
 * @returns A function to cancel the metrics request.
 */
export async function metrics(url, onMetrics, onError, cluster) {
    const handle = setInterval(getMetrics, 10000);
    const clusterName = cluster || getCluster();
    async function getMetrics() {
        try {
            const metric = await clusterRequest(url, { cluster: clusterName });
            onMetrics(metric.items || metric);
        }
        catch (err) {
            if (isDebugVerbose('k8s/apiProxy@metrics')) {
                console.debug('k8s/apiProxy@metrics', { err, url });
            }
            if (onError) {
                onError(err);
            }
        }
    }
    function cancel() {
        clearInterval(handle);
    }
    getMetrics();
    return cancel;
}
//@todo: these need documenting.
//@todo: these need return types.
export async function testAuth(cluster = '', namespace = 'default') {
    const spec = { namespace };
    const clusterName = cluster || getCluster();
    return post('/apis/authorization.k8s.io/v1/selfsubjectrulesreviews', { spec }, false, {
        timeout: 5 * 1000,
        cluster: clusterName,
    });
}
export async function testClusterHealth(cluster) {
    const clusterName = cluster || getCluster() || '';
    return clusterRequest('/healthz', { isJSON: false, cluster: clusterName });
}
export async function setCluster(clusterReq) {
    const kubeconfig = clusterReq.kubeconfig;
    let requestURL = '/cluster';
    if (kubeconfig) {
        await storeStatelessClusterKubeconfig(kubeconfig);
        // We just send parsed kubeconfig from the backend to the frontend.
        requestURL = '/parseKubeConfig';
    }
    return request(requestURL, {
        method: 'POST',
        body: JSON.stringify(clusterReq),
        headers: {
            ...JSON_HEADERS,
            ...getHeadlampAPIHeaders(),
        },
    }, false, false);
}
// @todo return type is configSlice Promise<ConfigState['clusters']>
// @todo: needs documenting.
export async function deleteCluster(cluster) {
    if (cluster) {
        const kubeconfig = await findKubeconfigByClusterName(cluster);
        if (kubeconfig !== null) {
            await deleteClusterKubeconfig(cluster);
            return window.location.reload();
        }
    }
    return request(`/cluster/${cluster}`, { method: 'DELETE', headers: { ...getHeadlampAPIHeaders() } }, false, false);
}
/**
 * renameCluster sends call to backend to update a field in kubeconfig which
 * is the custom name of the cluster used by the user.
 * @param cluster
 */
export async function renameCluster(cluster, newClusterName, source) {
    let stateless = false;
    if (cluster) {
        const kubeconfig = await findKubeconfigByClusterName(cluster);
        if (kubeconfig !== null) {
            stateless = true;
        }
    }
    return request(`/cluster/${cluster}`, {
        method: 'PUT',
        headers: { ...getHeadlampAPIHeaders() },
        body: JSON.stringify({ newClusterName, source, stateless }),
    }, false, false);
}
/**
 * parseKubeConfig sends call to backend to parse kubeconfig and send back
 * the parsed clusters and contexts.
 * @param clusterReq - The cluster request object.
 */
export async function parseKubeConfig(clusterReq) {
    const kubeconfig = clusterReq.kubeconfig;
    if (kubeconfig) {
        return request('/parseKubeConfig', {
            method: 'POST',
            body: JSON.stringify(clusterReq),
            headers: {
                ...JSON_HEADERS,
                ...getHeadlampAPIHeaders(),
            },
        }, false, false);
    }
    return null;
}
// @todo: Move startPortForward, stopPortForward, and getPortForwardStatus to a portForward.ts
// @todo: the return type is missing for the following functions.
//       See PortForwardState in PortForward.tsx
/**
 * Starts a portforward with the given details.
 *
 * @param cluster - The cluster to portforward for.
 * @param namespace - The namespace to portforward for.
 * @param podname - The pod to portforward for.
 * @param containerPort - The container port to portforward for.
 * @param service - The service to portforward for.
 * @param serviceNamespace - The service namespace to portforward for.
 * @param port - The port to portforward for.
 * @param id - The id to portforward for.
 *
 * @returns The response from the API.
 * @throws {Error} if the request fails.
 */
export function startPortForward(cluster, namespace, podname, containerPort, service, serviceNamespace, port, address = '', id = '') {
    const headers = new Headers({
        ...JSON_HEADERS,
    });
    const token = getToken(cluster);
    if (!!token) {
        headers.set('Authorization', `Bearer ${token}`);
    }
    return fetch(`${helpers.getAppUrl()}portforward`, {
        method: 'POST',
        headers,
        body: JSON.stringify({
            cluster,
            namespace,
            pod: podname,
            service,
            targetPort: containerPort.toString(),
            serviceNamespace,
            id: id,
            address,
            port,
        }),
    }).then((response) => {
        return response.json().then(data => {
            if (!response.ok) {
                throw new Error(data.message);
            }
            return data;
        });
    });
}
// @todo: stopOrDelete true is confusing, rename this param to justStop?
// @todo: needs a return type.
/**
 * Stops or deletes a portforward with the specified details.
 *
 * @param cluster - The cluster to portforward for.
 * @param id - The id to portforward for.
 * @param stopOrDelete - Whether to stop or delete the portforward. True for stop, false for delete.
 *
 * @returns The response from the API.
 * @throws {Error} if the request fails.
 */
export function stopOrDeletePortForward(cluster, id, stopOrDelete = true) {
    return fetch(`${helpers.getAppUrl()}portforward`, {
        method: 'DELETE',
        body: JSON.stringify({
            cluster,
            id,
            stopOrDelete,
        }),
    }).then(response => response.text().then(data => {
        if (!response.ok) {
            throw new Error('Error deleting port forward');
        }
        return data;
    }));
}
// @todo: needs a return type.
/**
 * Lists the port forwards for the specified cluster.
 *
 * @param cluster - The cluster to list the port forwards.
 *
 * @returns the list of port forwards for the cluster.
 */
export function listPortForward(cluster) {
    return fetch(`${helpers.getAppUrl()}portforward/list?cluster=${cluster}`).then(response => response.json());
}
// @todo: Move drainNode and drainNodeStatus to a drainNode.ts
/**
 * Drain a node
 *
 * @param cluster - The cluster to drain the node
 * @param nodeName - The node name to drain
 *
 * @returns {Promise<JSON>}
 * @throws {Error} if the request fails
 * @throws {Error} if the response is not ok
 *
 * This function is used to drain a node. It is used in the node detail page.
 * As draining a node is a long running process, we get the request received
 * message if the request is successful. And then we poll the drain node status endpoint
 * to get the status of the drain node process.
 */
export function drainNode(cluster, nodeName) {
    const headers = new Headers({
        ...JSON_HEADERS,
    });
    const token = getToken(cluster);
    if (!!token) {
        headers.set('Authorization', `Bearer ${token}`);
    }
    return fetch(`${helpers.getAppUrl()}drain-node`, {
        method: 'POST',
        headers,
        body: JSON.stringify({
            cluster,
            nodeName,
        }),
    }).then(response => {
        return response.json().then(data => {
            if (!response.ok) {
                throw new Error('Something went wrong');
            }
            return data;
        });
    });
}
/**
 * Get the status of the drain node process.
 *
 * It is used in the node detail page.
 * As draining a node is a long running process, we poll this endpoint to get
 * the status of the drain node process.
 *
 * @param cluster - The cluster to get the status of the drain node process for.
 * @param nodeName - The node name to get the status of the drain node process for.
 *
 * @returns - The response from the API. @todo: what response?
 * @throws {Error} if the request fails
 * @throws {Error} if the response is not ok
 */
export function drainNodeStatus(cluster, nodeName) {
    const headers = new Headers({
        ...JSON_HEADERS,
    });
    const token = getToken(cluster);
    if (!!token) {
        headers.set('Authorization', `Bearer ${token}`);
    }
    return fetch(`${helpers.getAppUrl()}drain-node-status?cluster=${cluster}&nodeName=${nodeName}`, {
        method: 'GET',
        headers,
    }).then(response => {
        return response.json().then((data) => {
            if (!response.ok) {
                throw new Error('Something went wrong');
            }
            return data;
        });
    });
}
/**
 * getClusterDefaultNamespace gives the default namespace for the given cluster.
 *
 * If the checkSettings parameter is true (default), it will check the cluster settings first.
 * Otherwise it will just check the cluster config. This means that if one needs the default
 * namespace that may come from the kubeconfig, call this function with the checkSettings parameter as false.
 *
 * @param cluster The cluster name.
 * @param checkSettings Whether to check the settings for the default namespace (otherwise it just checks the cluster config). Defaults to true.
 *
 * @returns The default namespace for the given cluster.
 */
function getClusterDefaultNamespace(cluster, checkSettings) {
    const includeSettings = checkSettings ?? true;
    let defaultNamespace = '';
    if (!!cluster) {
        if (includeSettings) {
            const clusterSettings = helpers.loadClusterSettings(cluster);
            defaultNamespace = clusterSettings?.defaultNamespace || '';
        }
        if (!defaultNamespace) {
            const state = store.getState();
            const clusterDefaultNs = state.config?.clusters?.[cluster]?.meta_data?.namespace || '';
            defaultNamespace = clusterDefaultNs;
        }
    }
    return defaultNamespace;
}
// @todo: needs a return type.
//@todo: what is DELETE /plugins/name response type? It's not used by headlamp in PLuginSettingsDetail.
/**
 * Deletes the plugin with the specified name from the system.
 *
 * This function sends a DELETE request to the server's plugin management
 * endpoint, targeting the plugin identified by its name.
 * The function handles the request asynchronously and returns a promise that
 * resolves with the server's response to the DELETE operation.
 *
 * @param {string} name - The unique name of the plugin to delete.
 *  This identifier is used to construct the URL for the DELETE request.
 *
 * @returns — A Promise that resolves to the JSON response from the API server.
 * @throws — An ApiError if the response status is not ok.
 *
 * @example
 * // Call to delete a plugin named 'examplePlugin'
 * deletePlugin('examplePlugin')
 *   .then(response => console.log('Plugin deleted successfully', response))
 *   .catch(error => console.error('Failed to delete plugin', error));
 */
export async function deletePlugin(name) {
    return request(`/plugins/${name}`, { method: 'DELETE', headers: { ...getHeadlampAPIHeaders() } }, false, false);
}
