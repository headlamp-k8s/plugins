"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toMatchSpecificSnapshot = toMatchSpecificSnapshot;
Object.defineProperty(exports, "addSerializer", {
  enumerable: true,
  get: function get() {
    return _jestSnapshot.addSerializer;
  }
});

var _path = _interopRequireDefault(require("path"));

var _jestSnapshot = require("jest-snapshot");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var snapshotsStateMap = new Map();
var commonSnapshotState;

function getAbsolutePathToSnapshot(testPath, snapshotFile) {
  return _path["default"].isAbsolute(snapshotFile) ? snapshotFile : _path["default"].resolve(_path["default"].dirname(testPath), snapshotFile);
}

afterAll(function () {
  snapshotsStateMap.forEach(function (snapshotState) {
    var uncheckedCount = snapshotState.getUncheckedCount();

    if (uncheckedCount) {
      snapshotState.removeUncheckedKeys();
    }

    snapshotState.save();

    if (commonSnapshotState) {
      // Update common state so we get the report right with added/update/unmatched snapshots.
      // Jest will display the "u" & "i" suggestion, plus displaying the right number of update/added/unmatched snapshots.
      commonSnapshotState.unmatched += snapshotState.unmatched;
      commonSnapshotState.matched += snapshotState.matched;
      commonSnapshotState.updated += snapshotState.updated;
      commonSnapshotState.added += snapshotState.added;
    }
  });
});

function toMatchSpecificSnapshot(received, snapshotFile) {
  var absoluteSnapshotFile = getAbsolutePathToSnapshot(this.testPath, snapshotFile); // store the common state to re-use it in "afterAll" hook.

  commonSnapshotState = this.snapshotState;
  var snapshotState = snapshotsStateMap.get(absoluteSnapshotFile);

  if (!snapshotState) {
    snapshotState = new _jestSnapshot.SnapshotState(absoluteSnapshotFile, {
      updateSnapshot: commonSnapshotState._updateSnapshot,
      snapshotPath: absoluteSnapshotFile,
      snapshotFormat: commonSnapshotState.snapshotFormat
    });
    snapshotsStateMap.set(absoluteSnapshotFile, snapshotState);
  }

  var newThis = _objectSpread(_objectSpread({}, this), {}, {
    snapshotState: snapshotState
  });

  var patchedToMatchSnapshot = _jestSnapshot.toMatchSnapshot.bind(newThis);

  for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    rest[_key - 2] = arguments[_key];
  }

  return patchedToMatchSnapshot.apply(void 0, [received].concat(rest));
}

expect.extend({
  toMatchSpecificSnapshot: toMatchSpecificSnapshot
});